//────────────────────────────────────────────
// VERSIONING
//────────────────────────────────────────────

Table version_family {
  id          int   [pk, increment]
  short_code  text  [not null, unique]  // 'theme', 'scenario', …
  label       text
  description text
  is_active   boolean [not null, default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (is_active, short_code) }

  Note: 'Version families define domains that can be versioned independently (theme, scenario, assumption, etc.)'
}

Ref: version_family.created_by > user.id [delete: restrict, update: cascade]
Ref: version_family.updated_by > user.id [delete: restrict, update: cascade]

Table domain_family_map {
  table_name        text [pk]
  version_family_id int  [not null]
  note              text

  Note: 'Maps individual tables to their version families. Enables tooling to fetch latest active version for any domain table.'
}

Ref: domain_family_map.version_family_id > version_family.id [delete: restrict, update: cascade]

Table version {
  id                int       [pk, increment]
  version_family_id int       [not null]
  version_number    text      // semver e.g. 2.1.0; use pg_semver extension
  manifest          jsonb     // Version metadata: config, feature flags, validation rules, etc.
  changelog         text      // Human-readable change description
  is_active         boolean   [not null, default: false]
  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [default: "now()"]
  updated_by  int

  Indexes {
    (version_family_id, version_number) [unique]
    (version_family_id) [unique, note: 'Postgres partial index WHERE is_active = TRUE']
    (manifest) [type: gin, note: 'JSONB search for version metadata']
  }

  Note: '''
    Version instances for each family. Only one version per family can be active at a time.
    CHECK (version_number ~ "^[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9.]+)?$")
    CHECK (NOT (is_active = TRUE AND EXISTS (
      SELECT 1 FROM version v2 
      WHERE v2.version_family_id = version.version_family_id 
      AND v2.is_active = TRUE 
      AND v2.id != version.id
    )))
  '''
}

Ref: version.version_family_id > version_family.id [delete: restrict, update: cascade]
Ref: version.created_by > user.id [delete: restrict, update: cascade]
Ref: version.updated_by > user.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// GLOBAL LOOKUP TABLES & ENUMS
//────────────────────────────────────────────

Table user {
  id           int       [pk, increment]
  email        text      [unique]                      // Primary email address
  name         text
  display_name text      [not null]                    // Full name or service description
  affiliation  text                                    // Organization/institution
  role         text                                    // 'researcher', 'analyst', 'admin', 'service'
  
  // AWS SSO Integration (for production)
  aws_sso_user_id  text  [unique]                     // AWS SSO user ID (populated post-deployment)
  aws_sso_username text  [unique]                     // AWS SSO username (populated post-deployment)
  
  // Bootstrap vs Production user tracking
  is_bootstrap boolean   [not null, default: false]   // TRUE for CSV bootstrap users
  sync_source  text      [default: 'manual']          // 'manual', 'aws_sso', 'bootstrap'
  
  // Status and metadata
  is_active    boolean   [not null, default: true]
  last_login   timestamp
  created_at   timestamp [not null, default: "now()"]
  updated_at   timestamp [not null, default: "now()"]

  Indexes {
    (email) [unique]
    (aws_sso_user_id) [unique]
    (aws_sso_username) [unique]
    (role, is_active)
    (is_bootstrap, is_active)
    (sync_source, is_active)
  }

  Note: '''
    Hybrid user table: Bootstrap users (CSV) for initialization, AWS SSO integration for production. Bootstrap users can be deactivated after AWS SSO sync.
    CHECK (email ~ "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$")
    CHECK (role IN ("researcher", "analyst", "admin", "service", "viewer"))
  '''
}

Table source {
    id          int     [pk, increment]
    source      text    [not null, unique]   // 'calsim_report', 'james_gilbert', 'calsim_variables', 'geopackage', 'trend_report'
    description text                          // Description of the data source
    is_active   boolean [not null, default: true]

    created_at  timestamp [not null, default: "now()"]
    created_by  int      [not null]
    updated_at  timestamp [not null, default: "now()"]
    updated_by  int      [not null]

    Indexes {
        (source) [unique]
        (is_active, source)
    }

    Note: 'Unified source lookup table for all entity types'
}

Ref: source.created_by > user.id [delete: restrict, update: cascade]
Ref: source.updated_by > user.id [delete: restrict, update: cascade]

Table calsim_entity_type {
  id                  int   [pk, increment]
  type                text  [not null, unique]   // 'reservoir', 'channel', 'inflow', 'demand_unit', 'groundwater', 'delta_node'
  schematic_type_id   int                        // FK → calsim_schematic_type.id  (NULL → not on network)
  description         text 
  key_dynamic         text
  is_active           boolean [default: true]

  Indexes { (is_active, type) }
}
Ref: calsim_entity_type.schematic_type_id > calsim_schematic_type.id

Table calsim_schematic_type {
  id          int  [pk, increment]
  label  text [not null, unique]   // 'arc', 'node', null
}

//────────────────────────────────────────────
// ENTITY SYSTEM
//────────────────────────────────────────────

/*
Entity-specific tables:
- reservoir_entity, channel_entity, inflow_entity
- reservoir_variable, channel_variable, inflow_variable
*/

Table hydrologic_region {
  id         int  [pk, increment]
  short_code text [not null, unique]   // 'SAC' | 'SJR' | 'Tul' | 'SoCal'
  label      text                      // full name ("Sacramento River", …)
  is_active  boolean [not null, default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { 
    (short_code) [unique]
    (is_active, short_code)
  }
}

Ref: hydrologic_region.created_by > user.id [delete: restrict, update: cascade]
Ref: hydrologic_region.updated_by > user.id [delete: restrict, update: cascade]

Table unit {
   id              int     [pk, increment]
   short_code      text    [not null, unique] // "cfs", "taf"
   full_name       text
   canonical_group text    // "flow", "volume", "length"
   is_active       boolean [not null, default: true]

   created_at  timestamp [not null, default: "now()"]
   created_by  int      [not null]
   updated_at  timestamp [not null, default: "now()"]
   updated_by  int      [not null]

   Indexes {
     (short_code) [unique]
     (is_active, short_code)
     (canonical_group)
   }
 }

Ref: unit.created_by > user.id [delete: restrict, update: cascade]
Ref: unit.updated_by > user.id [delete: restrict, update: cascade]

 Table flow_regime {
   id          int   [pk, increment]
   short_code  text  [not null, unique] // "dry_early"
   description text
 }

 Table season {
   id          int   [pk, increment]
   label       text  [not null, unique]  // "OND", "spring"
   start_month int   // 1-12  (optional)
   end_month   int
   notes       text

   Note: '''
     CHECK (start_month BETWEEN 1 AND 12)
     CHECK (end_month BETWEEN 1 AND 12)
   '''
 }

 Table region {
   id          int   [pk, increment]
   primary_name text [not null, unique]
   type        text
   alias_names text[]
   geom        geometry(Geometry,4326)
 }

Table hydroclimate_variable_type {
  id          int  [pk, increment]
  short_code  text [not null, unique]   // 'temperature', …
  unit_id     int                      // e.g. '°C'
  unit_hint   text                      // e.g. , 'mm day-1'
  description text
  is_active   boolean [default: true]

  Indexes { (is_active, short_code) }
}

Ref: hydroclimate_variable_type.unit_id > unit.id [delete: restrict, update: cascade]

/*
Enum hydroclimate_variable_type {
  temperature
  precipitation
  evapotranspiration
  streamflow
  other
}
*/

Table variable_type {
  id          int  [pk, increment]
  short_code  text [not null, unique]   // 'output', 'control', 'decision', 'input'
  label       text [not null]           // 'Model Output', 'Control Variable', 'Decision Variable'
  description text
  is_active   boolean [default: true]

  Indexes { (is_active, short_code) }
}

/*
Enum variable_frequency_type {
  monthly
  seasonal    // e.g. "spring"
  flow_seasonal // e.g. "dry_early"
  annual
  other
}
*/

Table analysis_type {
  id          int  [pk, increment]
  short_code  text [not null, unique]   // 'cobenefit', …
  label       text
  description text
  is_active   boolean [default: true]

  Indexes { (is_active, short_code) }
}

/*
Enum analysis_type {
  cobenefit
  tradeoff
  deviation
  important
  other
}
*/

Table geometry_type {
  id          int  [pk, increment]
  short_code  text [not null, unique]
  label       text
  description text
  is_active   boolean [default: true]

  Indexes { (is_active, short_code) }
}

/*
Enum geometry_type {
  demand_unit
  wba
  hydrologic_area
  basin
  reservoir
  stream
  aquifer
  other
}
*/

Table statistic_type {
  id          int    [pk, increment]
  code        text   [not null, unique] // e.g. 'p10'
  name        text   [not null]         // e.g. '10th percentile'
  description text
  is_percentile boolean [not null, default: false]

  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (code)        [unique]
  }
}

Ref: statistic_type.created_by > user.id  [delete: restrict, update: cascade]
Ref: statistic_type.updated_by > user.id  [delete: restrict, update: cascade]

/*
INSERT INTO statistic_type (code, name, is_percentile, created_by, updated_by)
VALUES
  ('mean',   'Mean',                  FALSE, :system_user, :system_user),
  ('median', 'Median',                FALSE, :system_user, :system_user),
  ('min',    'Minimum',               FALSE, :system_user, :system_user),
  ('max',    'Maximum',               FALSE, :system_user, :system_user),
  ('p05',    '5th percentile',        TRUE,  :system_user, :system_user),
  ('p10',    '10th percentile',       TRUE,  :system_user, :system_user),
  ('p25',    '25th percentile',       TRUE,  :system_user, :system_user),
  ('p75',    '75th percentile',       TRUE,  :system_user, :system_user),
  ('p90',    '90th percentile',       TRUE,  :system_user, :system_user),
  ('p95',    '95th percentile',       TRUE,  :system_user, :system_user),
  ('other',  'Other / custom value',  FALSE, :system_user, :system_user);

-- Variable types for categorizing variables by purpose...not sure if doing this...if this is helpful. Could implement later if there is a need.
INSERT INTO variable_type (short_code, label, description, created_by, updated_by)
VALUES
  ('output', 'Model Output', 'Standard CalSim model output variables (flows, storage, etc.)', :system_user, :system_user),
  ('control', 'Control Variable', 'Operational control indicators and binary flags', :system_user, :system_user),
  ('decision', 'Decision Variable', 'Model decision variables and optimization targets', :system_user, :system_user),
  ('state', 'State Variable', 'State variables including storage zones and bookkeeping accounts', :system_user, :system_user),
  ('input', 'Input Variable', 'External inputs and boundary conditions', :system_user, :system_user),
  ('intermediate', 'Intermediate Variable', 'Calculated intermediate values used in model logic', :system_user, :system_user),
  ('aggregate', 'Aggregate Variable', 'Variables that sum or combine multiple reservoir/system components', :system_user, :system_user);
  */

//────────────────────────────────────────────
// CORE ENTITIES
//────────────────────────────────────────────

Table theme {
  id          int       [pk, increment]
  short_code  text      [not null]
  is_active   boolean   [not null, default: false]
  title       text      [not null]
  subtitle    text
  short_title text
  simple_description text
  description text
  description_next text
  narrative   jsonb
  outcome_description text
  outcome_narrative text
  source text
  theme_version_id int       [not null]
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code, is_active) [unique, note: 'UNIQUE WHERE is_active = TRUE']
    (is_active)
    (short_code) [note: 'Partial index WHERE is_active = TRUE']
  }

  Note: '''
    CHECK (short_code ~ "^[a-z0-9_]+$" AND length(short_code) BETWEEN 2 AND 50)
  '''
}

Ref: theme.theme_version_id > version.id [delete: restrict, update: cascade]
Ref: theme.created_by > user.id [delete: restrict, update: cascade]
Ref: theme.updated_by > user.id [delete: restrict, update: cascade]

Table scenario {
  id                   int      [pk, increment]
  short_code           text      [not null]
  is_active            boolean   [not null, default: false]
  title                text      [not null]
  subtitle             text
  short_title          text
  simple_description   text
  description          text
  narrative            jsonb
  baseline_scenario_id int                // NULL for baselines
  hydroclimate_id      int
  scenario_author_id            int
  scenario_version_id  int       [not null]
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code, is_active) [unique, note: 'UNIQUE WHERE is_active = TRUE']
    (is_active)
    (baseline_scenario_id)
    (hydroclimate_id)
    (is_active, scenario_version_id) [note: 'Partial index WHERE is_active = TRUE']
    (narrative) [type: gin, note: 'JSONB search']
    (title, description) [type: gin, note: 'Full-text search using to_tsvector']
  }
}

Ref: scenario.baseline_scenario_id > scenario.id [delete: set null, update: cascade]
Ref: scenario.hydroclimate_id > hydroclimate.id [delete: restrict, update: cascade]
Ref: scenario.scenario_author_id > scenario_author.id [delete: restrict, update: cascade]
Ref: scenario.scenario_version_id > version.id [delete: restrict, update: cascade]
Ref: scenario.created_by > user.id    [delete: restrict, update: cascade]
Ref: scenario.updated_by > user.id    [delete: restrict, update: cascade]

// Theme ↔ Scenario
Table theme_scenario_link {
  theme_id    int  [not null]
  scenario_id int  [not null]

  Indexes { 
    (theme_id, scenario_id) [pk]      // scenarios per theme
    (scenario_id, theme_id)           // themes per scenario
  }
}

Ref: theme_scenario_link.theme_id    > theme.id    [delete: restrict, update: cascade]
Ref: theme_scenario_link.scenario_id > scenario.id [delete: restrict, update: cascade]

Table theme_source {
  id            int   [pk, increment]
  short_code    text  [not null, unique]
  name          text  [not null]              // e.g. "May 2025 Advisory Cohort Posters"
  citation      text                         
  url           text
  doc_date      date
  notes         text

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}

Ref: theme_source.created_by > user.id [delete: restrict, update: cascade]
Ref: theme_source.updated_by > user.id [delete: restrict, update: cascade]

// Theme ↔ Theme Source
Table theme_source_link {
  theme_id   int  [not null]
  theme_source_id  int  [not null]
}

Ref: theme_source_link.theme_id > theme.id [delete: restrict, update: cascade]
Ref: theme_source_link.theme_source_id > theme_source.id [delete: restrict, update: cascade]

Table scenario_author {
  id            int   [pk, increment]
  short_code    text  [not null, unique]
  name          text  [not null]              // e.g. "James Gilbert"
  email         text
  organization  text                          // e.g. "NOAA Southwest Fisheries Science Center"
  affiliation   text                          // e.g. "COEQWAL"
  is_active     boolean [not null, default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code) [unique]
    (is_active, short_code)
  }

  Note: 'Authors of CalSim scenarios and studies'
}

Ref: scenario_author.created_by > user.id [delete: restrict, update: cascade]
Ref: scenario_author.updated_by > user.id [delete: restrict, update: cascade]

Table scenario_source {
  id            int   [pk, increment]
  short_code    text  [not null, unique]
  name          text  [not null]              // e.g. "COEQWAL_phase1_Gilbert"
  citation      text                         
  url           text
  doc_date          date
  notes         text

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code) [unique]
  }
}

Ref: scenario_source.created_by > user.id [delete: restrict, update: cascade]
Ref: scenario_source.updated_by > user.id [delete: restrict, update: cascade]

// Scenario ↔ Scenario Source
Table scenario_source_link {
  scenario_id int [not null]
  scenario_source_id   int  [not null]
}

Ref: scenario_source_link.scenario_id > scenario.id [delete: restrict, update: cascade]
Ref: scenario_source_link.scenario_source_id > scenario_source.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// ASSUMPTIONS
//────────────────────────────────────────────

Table assumption_category {
  id          int    [pk, increment]
  short_code        text   [not null, unique]  // slr, land_use, etc.
  label       text   [not null] 
  description text
  is_active   boolean   [not null, default: true]
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (is_active, short_code)
  }
}

Ref: assumption_category.created_by > user.id [delete: restrict, update: cascade]
Ref: assumption_category.updated_by > user.id [delete: restrict, update: cascade]

/*

INSERT INTO assumption_category (short_code, label)
VALUES
  ('tucp_tuco',       'TUCP/TUCO'),
  ('land_use',        'land use'),
  ('gw_restrictions', 'groundwater restrictions'),
  ('slr',             'sea level rise'),
  ('gwmodel',         'groundwater model'),
  ('other',           'other');

*/

Table assumption_definition {
  id                int   [pk, increment]
  short_code        text  [not null]
  title             text  [not null]
  category_id       int   [not null]
  description       text
  source            text
  source_access_date date
  file              text
  assumptions_version_id int [not null]
  is_active   boolean   [not null, default: true]
  notes       text
  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp
  updated_by  int

  Indexes {
    (category_id, short_code) [unique, note: 'UNIQUE WHERE is_active']
    (is_active)
  }
}

Ref: assumption_definition.category_id > assumption_category.id [delete: restrict, update: cascade]
Ref: assumption_definition.assumptions_version_id > version.id [delete: restrict, update: cascade]
Ref: assumption_definition.created_by > user.id [delete: restrict, update: cascade]
Ref: assumption_definition.updated_by > user.id [delete: restrict, update: cascade]

Table assumption_param_TUCP_TUCO {
  id              int  [pk, increment]
  assumption_id int  [not null]
  region_id   int
  season_id   int
  detail       jsonb

  Indexes { (assumption_id) }
}

Ref: assumption_param_TUCP_TUCO.assumption_id > assumption_definition.id [delete: cascade, update: restrict]
Ref: assumption_param_TUCP_TUCO.region_id > region.id [delete: restrict, update: cascade]
Ref: assumption_param_TUCP_TUCO.season_id > season.id [delete: restrict, update: cascade]

Table assumption_param_land_use {
  id              int  [pk, increment]
  assumption_id int       [not null]
  crop          text
  amount      numeric
  unit_id     int
  region_id   int
  season_id   int
  detail       jsonb
  Indexes { (assumption_id, crop) [unique] }
}

Ref: assumption_param_land_use.assumption_id > assumption_definition.id [delete: cascade, update: restrict]
Ref: assumption_param_land_use.unit_id > unit.id [delete: restrict, update: cascade]
Ref: assumption_param_land_use.season_id > season.id [delete: restrict, update: cascade]

Table assumption_param_SGMA {
  id              int  [pk, increment]
  assumption_id int       [not null]
  region_id  int
  amount    numeric
  unit_id int
  detail jsonb
  Indexes { (assumption_id, region_id) [unique] }
}

Ref: assumption_param_SGMA.assumption_id > assumption_definition.id [delete: cascade, update: restrict]
Ref: assumption_param_SGMA.region_id > region.id [delete: restrict, update: cascade]
Ref: assumption_param_SGMA.unit_id > unit.id [delete: restrict, update: cascade]

Table assumption_param_slr {
  id              int  [pk, increment]
  assumption_id  int       [not null]
  projection_year int
  slr         numeric
  unit_id     int
  detail jsonb
  Indexes { (assumption_id, slr, unit_id) [unique] }
}

Ref: assumption_param_slr.assumption_id > assumption_definition.id [delete: cascade, update: restrict]
Ref: assumption_param_slr.unit_id > unit.id [delete: restrict, update: cascade]

Table assumption_param_gwmodel {
  id              int  [pk, increment]
  assumption_id int       [not null]
  detail        jsonb
  Indexes { (assumption_id) }
}

Ref: assumption_param_gwmodel.assumption_id > assumption_definition.id [delete: cascade, update: restrict]

Table assumption_param_bioops {
  id              int  [pk, increment]
  assumption_id int       [not null]
  detail        jsonb
  Indexes { (assumption_id) }
}

Ref: assumption_param_bioops.assumption_id > assumption_definition.id [delete: cascade, update: restrict]

Table assumption_param_kv {
  id              int  [pk, increment]
  assumption_id int       [not null]
  key           text      [not null]
  value_num     numeric
  value_txt     text
  Note: 'CHECK ( (value_num IS NOT NULL)::int + (value_txt IS NOT NULL)::int = 1 )'

  unit_id       int
  region_id     int
  season_id     int
  detail       jsonb

  Indexes {
    (assumption_id, key) [unique]
  }
}

Ref: assumption_param_kv.assumption_id > assumption_definition.id [delete: cascade, update: restrict]
Ref: assumption_param_kv.unit_id > unit.id [delete: restrict, update: cascade]
Ref: assumption_param_kv.region_id > region.id [delete: restrict, update: cascade]
Ref: assumption_param_kv.season_id > season.id [delete: restrict, update: cascade]

Table theme_key_assumption_link {
  theme_id                 int  [not null]
  assumption_definition_id int  [not null]

  Indexes {
    (theme_id, assumption_definition_id) [pk]      // theme → assumptions
    (assumption_definition_id, theme_id)           // assumption → themes
  }
}

Ref: theme_key_assumption_link.theme_id                 > theme.id                 [delete: restrict, update: cascade]
Ref: theme_key_assumption_link.assumption_definition_id > assumption_definition.id [delete: restrict, update: cascade]

Table scenario_key_assumption_link {
  scenario_id   int [not null]
  assumption_id int [not null]

  Indexes {
    (scenario_id, assumption_id) [pk]   // scenario → assumptions
    (assumption_id, scenario_id)        // assumption → scenarios
  }
}

Ref: scenario_key_assumption_link.scenario_id  > scenario.id            [delete: restrict, update: cascade]
Ref: scenario_key_assumption_link.assumption_id > assumption_definition.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// OPERATIONS
//────────────────────────────────────────────

Table operation_category {
  id          int  [pk, increment]
  short_code  text [not null, unique]
  name        text
  description text
  is_active   boolean [not null, default: true]
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (is_active, short_code) }
}
  
Ref: operation_category.created_by > user.id [delete: restrict, update: cascade]
Ref: operation_category.updated_by > user.id [delete: restrict, update: cascade]

/*
INSERT INTO operation_category (short_code, label)
VALUES
  ('infrastructure',       'infrastructure'),
  ('regulatory',        'regulatory'),
  ('priority_allocation', 'priority allocation),
  ('min_flow',             'minimum flow'),
  ('gw_pumping_limit',         'groundwater pumping limit]'),
  ('ag_delivery',         'agricultural delivery]'),
  ('comm_delivery',         'community delivery]'),
  ('env_delivery',         'environmental delivery]'),
  ('delta_outflow',         'Delta outflow]'),
  ('carryover',         'reservoir carryover]'),
  ('other',           'other');
*/

Table operation_definition {
  id                   int                 [pk, increment]
  short_code           text                [not null]
  name                 text                [not null]
  category_id          int  [not null]
  description          text
  is_active          boolean   [not null, default: true]
  notes       text
  operation_version_id int    [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (is_active)
    (category_id, short_code)  [unique, note: 'UNIQUE WHERE is_active'] 
  }
}

Ref: operation_definition.operation_version_id > version.id [delete: restrict, update: cascade]
Ref: operation_definition.category_id > operation_category.id [delete: restrict, update: cascade]
Ref: operation_definition.created_by          > user.id    [delete: restrict, update: cascade]
Ref: operation_definition.updated_by          > user.id    [delete: restrict, update: cascade]

Table operation_param_priority_allocation {
  id              int    [pk, increment]
  operation_id    int    [not null]
  allocation_type text
  region_id       int
  season_id       int
  detail          jsonb

  Indexes {
    (operation_id)
  }
}

Ref: operation_param_priority_allocation.operation_id  > operation_definition.id [delete: cascade, update: restrict]
Ref: operation_param_priority_allocation.region_id > region.id [delete: restrict, update: cascade]
Ref: operation_param_priority_allocation.season_id > season.id [delete: restrict, update: cascade]

Table operation_param_minimum_flow {
  id            int    [pk, increment]
  operation_id  int    [not null]
  tributary     text
  region_id     int
  season_id     int
  flow_regime_id   int
  flow_target_value   numeric
  unit_id       int
  detail        jsonb

  Indexes {
    (operation_id) 
    (operation_id, tributary) [unique]
  }
}

Ref: operation_param_minimum_flow.operation_id  > operation_definition.id [delete: cascade, update: restrict]
Ref: operation_param_minimum_flow.region_id > region.id [delete: restrict, update: cascade]
Ref: operation_param_minimum_flow.season_id > season.id [delete: restrict, update: cascade]
Ref: operation_param_minimum_flow.flow_regime_id > flow_regime.id [delete: restrict, update: cascade]
Ref: operation_param_minimum_flow.unit_id > unit.id [delete: restrict, update: cascade]

Table operation_param_infrastructure {
  id                  int    [pk, increment]
  operation_id        int    [not null]
  infrastructure_name text
  operation_level     text
  unit_id       int
  detail          jsonb

  Indexes {
    (operation_id) 
    (operation_id, infrastructure_name) [unique]
  }
}

Ref: operation_param_infrastructure.operation_id  > operation_definition.id [delete: cascade, update: restrict]
Ref: operation_param_infrastructure.unit_id > unit.id [delete: restrict, update: cascade]

Table operation_param_regulatory {
  id             int    [pk, increment]
  operation_id   int    [not null]
  regulation_type int
  regulation_name text
  detail          jsonb

  Indexes {
    (operation_id) 
    (operation_id, regulation_type, regulation_name) [unique]
  }
}

Ref: operation_param_regulatory.operation_id  > operation_definition.id [delete: cascade, update: restrict]

Table operation_param_carryover {
  id             int    [pk, increment]
  operation_id   int    [not null]
  reservoir_id int
  amount numeric
  unit_id  int
  detail          jsonb

  Indexes {
    (operation_id) 
    (operation_id, reservoir_id, amount) [unique]
  }
}

Ref: operation_param_carryover.operation_id  > operation_definition.id [delete: cascade, update: restrict]
Ref: operation_param_carryover.reservoir_id  > reservoir_entity.id [delete: cascade, update: restrict]
Ref: operation_param_carryover.unit_id > unit.id [delete: restrict, update: cascade]

Table operation_param_kv {
  id             int    [pk, increment]
  operation_id int       [not null]
  key          text      [not null]
  value_num     numeric
  value_txt     text
  Note: 'CHECK ( (value_num IS NOT NULL)::int + (value_txt IS NOT NULL)::int = 1 )'

  unit_id       int
  region_id     int
  season_id     int
  detail       jsonb

  Indexes {
    (operation_id, key) [unique]
  }
}

Ref: operation_param_kv.operation_id  > operation_definition.id [delete: cascade, update: restrict]
Ref: operation_param_kv.unit_id > unit.id [delete: restrict, update: cascade]
Ref: operation_param_kv.region_id > region.id [delete: restrict, update: cascade]
Ref: operation_param_kv.season_id > season.id [delete: restrict, update: cascade]

Table theme_key_operation_link {
  theme_id       int [not null]
  operation_id   int [not null]

  Indexes {
    (theme_id, operation_id) [pk]
    (operation_id, theme_id)
  }
}

Ref: theme_key_operation_link.theme_id     > theme.id                [delete: restrict, update: cascade]
Ref: theme_key_operation_link.operation_id > operation_definition.id [delete: restrict, update: cascade]

Table scenario_key_operation_link {
  scenario_id  int [not null]
  operation_id int [not null]

  Indexes {
    (scenario_id, operation_id) [pk]
    (operation_id, scenario_id)
  }
}

Ref: scenario_key_operation_link.scenario_id  > scenario.id           [delete: restrict, update: cascade]
Ref: scenario_key_operation_link.operation_id > operation_definition.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// OUTCOMES
//────────────────────────────────────────────

Table outcome_category {
  id          int  [pk, increment]
  short_code  text [not null, unique]
  label       text
  description text
  outcome_version_id int  [not null]
  is_active   boolean [default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (is_active, short_code) }
}

Ref: outcome_category.outcome_version_id > version.id           [delete: restrict, update: cascade]
Ref: outcome_category.created_by         > user.id      [delete: restrict, update: cascade]
Ref: outcome_category.updated_by         > user.id      [delete: restrict, update: cascade]

Table outcome_measure {
  id                int  [pk, increment]
  outcome_category_id       int  [not null] 
  short_code        text [not null]               
  name              text [not null]
  description       text
  unit_id           int                           
  temporal_scale_id int                           
  spatial_scale_id  int                           
  calc_note         text                          
  metrics_version_id int [not null]
  is_active         boolean [default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
                               
  Indexes {
    (outcome_category_id, short_code) [unique, note: 'UNIQUE WHERE is_active = TRUE']
    (is_active)
    (outcome_category_id, short_code) [note: 'Partial index WHERE is_active = TRUE']
  }
}

Ref: outcome_measure.outcome_category_id       > outcome_category.id [delete: restrict, update: cascade]
Ref: outcome_measure.unit_id           > unit.id             [delete: restrict, update: cascade]
Ref: outcome_measure.temporal_scale_id > temporal_scale.id   [delete: restrict, update: cascade]
Ref: outcome_measure.spatial_scale_id  > spatial_scale.id    [delete: restrict, update: cascade]
Ref: outcome_measure.metrics_version_id > version.id            [delete: restrict, update: cascade]
Ref: outcome_measure.created_by        > user.id        [delete: restrict, update: cascade]
Ref: outcome_measure.updated_by        > user.id        [delete: restrict, update: cascade]

Table measure_variable_link {
  measure_id  int  [not null]
  variable_id uuid [not null]

  Indexes {
    (measure_id, variable_id) [pk]   // measure → variable
    (variable_id, measure_id)        // variable → measure
  }
}

Ref: measure_variable_link.measure_id  > outcome_measure.id  [delete: restrict, update: cascade]

//────────────────────────────────────────────
// LOOKUPS FOR OUTCOME METADATA
//────────────────────────────────────────────

Table temporal_scale {
  id          int  [pk, increment]
  short_code  text [not null, unique]   // 'monthly', 'annual', 'por', 'daily', 'seasonal'
  label       text [not null]           // 'Monthly', 'Annual', 'Period of Record'
  description text
  is_active   boolean [not null, default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code) [unique]
    (is_active, short_code)
  }
}

Ref: temporal_scale.created_by > user.id [delete: restrict, update: cascade]
Ref: temporal_scale.updated_by > user.id [delete: restrict, update: cascade]

Table spatial_scale {
  id          int  [pk, increment]
  short_code  text [not null, unique]   // 'demand_unit', 'reservoir', …
  label       text
  description text
  is_active   boolean [not null, default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code) [unique]
    (is_active, short_code)
  }
}

Ref: spatial_scale.created_by > user.id [delete: restrict, update: cascade]
Ref: spatial_scale.updated_by > user.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// MAPPING CalSim VARIABLES → OUTCOMES
//────────────────────────────────────────────

Table outcome_variable_link {             
  outcome_id  int  [not null]
  variable_id uuid [not null]

  Indexes {
    (outcome_id, variable_id) [pk]        // outcome → variable(s)
    (variable_id, outcome_id)             // variable → outcome
  }
}

Ref: outcome_variable_link.outcome_id > outcome_measure.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// DATABASE SUMMARY STATISTICS (S3 stores raw time series)
// Pre-computed statistics for fast queries without S3 access
//────────────────────────────────────────────

Table scenario_variable_statistic {
  scenario_id        int [not null]
  variable_id        uuid [not null]
  statistic_type_id  int  [not null]
  value              numeric [not null]
  source_version_id  int    [not null]

  created_at  timestamp [default: "now()"]
  created_by  int
  updated_at  timestamp
  updated_by  int

  Indexes {
    (scenario_id, variable_id, statistic_type_id) [pk]
    (variable_id, statistic_type_id)
    (scenario_id, variable_id)
    (variable_id, scenario_id) [note: 'Cross-scenario variable analysis']
  }

  Note: '''
    DATABASE STORAGE: Pre-computed summary statistics (mean, p10, p90, etc.) stored in database.
    RAW TIME SERIES: Full 100-year monthly time series (1,200 records) stored as Parquet files in S3.
    
    This table provides fast access to key statistics without loading full time series from S3.
    Statistics computed from S3 time series during ETL processing.
    
    CHECK (value >= 0)
    PARTITION BY RANGE (scenario_id)
    -- Partitioned for improved query performance on large datasets
  '''
}

Ref: scenario_variable_statistic.source_version_id > version.id            [delete: restrict, update: cascade]
Ref: scenario_variable_statistic.scenario_id         > scenario.id      [delete: restrict, update: cascade]
Ref: scenario_variable_statistic.statistic_type_id         > statistic_type.id      [delete: restrict, update: cascade]
Ref: scenario_variable_statistic.created_by         > user.id      [delete: restrict, update: cascade]
Ref: scenario_variable_statistic.updated_by         > user.id      [delete: restrict, update: cascade]

Table scenario_measure_statistic {
  scenario_id        int [not null]
  measure_id         int  [not null]
  statistic_type_id  int  [not null]
  value              numeric [not null]
  source_version_id  int    [not null]

  created_at  timestamp [default: "now()"]
  created_by  int
  updated_at  timestamp
  updated_by  int

  Indexes {
    (scenario_id, measure_id, statistic_type_id) [pk]
    (measure_id, statistic_type_id) [note: 'Cross-scenario look-ups']
    (measure_id, scenario_id) [note: 'Cross-scenario measure analysis']
  }

  Note: '''
    CHECK (value >= 0)
  '''
}

Ref: scenario_measure_statistic.measure_id > outcome_measure.id [delete: restrict, update: cascade]
Ref: scenario_measure_statistic.source_version_id > version.id            [delete: restrict, update: cascade]
Ref: scenario_measure_statistic.scenario_id         > scenario.id      [delete: restrict, update: cascade]
Ref: scenario_measure_statistic.statistic_type_id         > statistic_type.id      [delete: restrict, update: cascade]
Ref: scenario_measure_statistic.created_by         > user.id      [delete: restrict, update: cascade]
Ref: scenario_measure_statistic.updated_by         > user.id      [delete: restrict, update: cascade]

Table scenario_outcome_statistic {
  scenario_id      int [not null]
  outcome_id       int  [not null]
  statistic_type_id int  [not null]
  value            numeric [not null]

  source_version_id int [not null]
  created_at  timestamp [default: "now()"]
  created_by  int
  updated_at  timestamp
  updated_by  int

  Indexes {
    (scenario_id, outcome_id, statistic_type_id) [pk]
    (outcome_id, statistic_type_id)
  }
}

Ref: scenario_outcome_statistic.source_version_id > version.id            [delete: restrict, update: cascade]
Ref: scenario_outcome_statistic.scenario_id         > scenario.id      [delete: restrict, update: cascade]
Ref: scenario_outcome_statistic.outcome_id         > outcome_measure.id      [delete: restrict, update: cascade]
Ref: scenario_outcome_statistic.statistic_type_id         > statistic_type.id      [delete: restrict, update: cascade]
Ref: scenario_outcome_statistic.created_by         > user.id      [delete: restrict, update: cascade]
Ref: scenario_outcome_statistic.updated_by         > user.id      [delete: restrict, update: cascade]

Table scenario_category_statistic {
  scenario_id      int [not null, ref: > scenario.id]
  category_id      int  [not null, ref: > outcome_category.id]
  statistic_type_id int  [not null, ref: > statistic_type.id]
  value            numeric [not null]
  source_version_id int [not null, ref: > version.id]
  created_at  timestamp [default: "now()"]
  created_by  int
  updated_at  timestamp
  updated_by  int

  Indexes {
    (scenario_id, category_id, statistic_type_id) [pk]
    (category_id, statistic_type_id)
  }
}

//═══════════════════════════════════════════════
// THEME-OUTCOME INTEGRATION
//═══════════════════════════════════════════════

Table theme_outcome_priority {
  theme_id            int     [not null]              // FK → theme.id
  outcome_category_id int     [not null]              // FK → outcome_category.id  
  priority_rank       int     [not null]              // 1 = highest priority for this theme
  focus_weight        numeric [default: 1.0]          // Relative importance weight (0.0-1.0)
  research_rationale  text                            // Why this outcome is key for this theme
  measurement_focus   text                            // Specific measurement emphasis for theme
  
  created_at          timestamp [not null, default: "now()"]
  created_by          int      [not null]
  updated_at          timestamp
  updated_by          int

  Indexes {
    (theme_id, priority_rank) [unique]                // Each rank unique within theme
    (theme_id, outcome_category_id) [unique]          // Each outcome unique within theme
    (outcome_category_id, theme_id)                   // Reverse lookup
    (priority_rank)                                   // Cross-theme priority analysis
  }

  Note: '''
    Links themes to prioritized outcome categories with research focus details
    CHECK (focus_weight >= 0.0 AND focus_weight <= 1.0)
  '''
}

Ref: theme_outcome_priority.theme_id            > theme.id            [delete: cascade, update: cascade]
Ref: theme_outcome_priority.outcome_category_id > outcome_category.id [delete: restrict, update: cascade]
Ref: theme_outcome_priority.created_by          > user.id      [delete: restrict, update: cascade]
Ref: theme_outcome_priority.updated_by          > user.id      [delete: restrict, update: cascade]

Table theme_outcome_measure_focus {
  theme_id         int     [not null]              // FK → theme.id
  outcome_measure_id int   [not null]              // FK → outcome_measure.id
  focus_level      text    [not null]              // 'primary', 'secondary', 'contextual'
  analytical_emphasis text                         // Specific analytical focus for this theme
  tier_relevance   boolean [default: false]       // TRUE if tier classification is key for theme
  
  created_at       timestamp [not null, default: "now()"]
  created_by       int      [not null]

  Indexes {
    (theme_id, outcome_measure_id) [pk]
    (outcome_measure_id, theme_id)
    (focus_level)
    (tier_relevance)
  }

  Note: 'Links themes to specific outcome measures with analytical focus details'
}

Ref: theme_outcome_measure_focus.theme_id           > theme.id         [delete: cascade, update: cascade]
Ref: theme_outcome_measure_focus.outcome_measure_id > outcome_measure.id [delete: restrict, update: cascade]
Ref: theme_outcome_measure_focus.created_by         > user.id    [delete: restrict, update: cascade]

//────────────────────────────────────────────
// HYDROCLIMATE
//────────────────────────────────────────────

Table hydroclimate_source {
  id                      int       [pk, increment]
  short_code              text      [not null, unique]
  name                    text
  description             text
  citation                text
  url                     text
  notes                   text
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (short_code) }
}

Ref: hydroclimate_source.created_by          > user.id    [delete: restrict, update: cascade]
Ref: hydroclimate_source.updated_by          > user.id    [delete: restrict, update: cascade]

Table hydroclimate {
  id                      int       [pk, increment]
  short_code              text      [not null, unique]
  name                    text
  description             text
  is_active               boolean [not null, default: true]
  projection_year         int
  slr_value               numeric
  slr_unit_id             int
  source_id               int                       // FK → hydroclimate_source.id
  notes                   text
  hydroclimate_version_id int
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (is_active, short_code) (source_id) }
}

Ref: hydroclimate.hydroclimate_version_id > version.id            [delete: restrict, update: cascade]
Ref: hydroclimate.source_id              > hydroclimate_source.id [delete: restrict, update: cascade]
Ref: hydroclimate.slr_unit_id            > unit.id              [delete: restrict, update: cascade]
Ref: hydroclimate.created_by             > user.id            [delete: restrict, update: cascade]
Ref: hydroclimate.updated_by             > user.id            [delete: restrict, update: cascade]

Table hydroclimate_variable_summary {
  id                  int       [pk, increment]
  hydroclimate_id     int       [not null]
  variable_type_id    int [not null]
  unit_id             int
  description         text
  distribution_data   jsonb   
  variable_version_id int       [not null]
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (hydroclimate_id, variable_type_id) [unique]
  }
}

Ref: hydroclimate_variable_summary.variable_type_id > hydroclimate_variable_type.id [delete: restrict, update: cascade]
Ref: hydroclimate_variable_summary.hydroclimate_id > hydroclimate.id [delete: cascade, update: restrict]
Ref: hydroclimate_variable_summary.unit_id         > unit.id      [delete: restrict, update: cascade]
Ref: hydroclimate_variable_summary.variable_version_id > version.id   [delete: restrict, update: cascade]
Ref: hydroclimate_variable_summary.created_by             > user.id            [delete: restrict, update: cascade]
Ref: hydroclimate_variable_summary.updated_by             > user.id            [delete: restrict, update: cascade]

//────────────────────────────────────────────
// CALSIM VARIABLES
//────────────────────────────────────────────

// REMOVED: calsim_variable table - using entity-specific variable tables instead
// (reservoir_variable, channel_variable, inflow_variable)

//────────────────────────────────────────────
// VARIABLE GROUPING SYSTEM
//────────────────────────────────────────────

// Define types of variable groups
Table variable_group_type {
  id          int    [pk, increment]
  short_code  text   [not null, unique]   // 'tier_storage', 'reporting', 'analysis', 'dashboard'
  name        text   [not null]           // 'Tier Storage Variables', 'Reporting Variables'
  description text
  is_active   boolean [not null, default: true]
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code) [unique]
    (is_active, short_code)
  }
}

Ref: variable_group_type.created_by > user.id [delete: restrict, update: cascade]
Ref: variable_group_type.updated_by > user.id [delete: restrict, update: cascade]

// Define specific variable groups
Table variable_group {
  id                   int     [pk, increment]
  group_type_id        int     [not null]           // FK → variable_group_type.id
  short_code           text    [not null]           // 'tier_storage_reservoirs', 'dashboard_storage'
  name                 text    [not null]           // 'Tier Storage Reservoirs', 'Dashboard Storage Variables'
  description          text
  purpose              text                         // 'Used for tier classification of reservoir storage'
  selection_criteria   text                         // 'Major storage reservoirs with capacity > 100 TAF'
  is_active            boolean [not null, default: true]
  variable_version_id  int     [not null]           // FK → version.id (for versioning group definitions)
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (group_type_id, short_code) [unique]
    (is_active, group_type_id)
  }
}

Ref: variable_group.group_type_id       > variable_group_type.id [delete: restrict, update: cascade]
Ref: variable_group.variable_version_id > version.id                [delete: restrict, update: cascade]
Ref: variable_group.created_by          > user.id           [delete: restrict, update: cascade]
Ref: variable_group.updated_by          > user.id           [delete: restrict, update: cascade]

//────────────────────────────────────────────
// SCENARIO OUTCOMES & TIERS
//────────────────────────────────────────────
Table outcome_definition {
  id                 int   [pk, increment]
  name               text  [unique, not null]
  description        text
  units              text
  method             text
  source             text
  metrics_version_id int   [not null]
  created_at         timestamp [default: "now()"]
  updated_at         timestamp
}

Ref: outcome_definition.metrics_version_id > version.id [delete: restrict, update: cascade]

Table tier_definition {
  id              int  [pk, increment]
  name            text [not null, unique]
  description     text
  rationale       text
  method          text
  outcome_measures text[]
  is_active       boolean   [not null, default: false]
  tier_version_id int       [not null]
  created_at      timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at      timestamp [default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (is_active, name)
  }
}

Ref: tier_definition.tier_version_id > version.id [delete: restrict, update: cascade]
Ref: tier_definition.created_by  > user.id   [delete: restrict, update: cascade]
Ref: tier_definition.updated_by  > user.id   [delete: restrict, update: cascade]

Table tier_level {
  tier_id             int  [not null]
  level               int  [not null]

  label               text
  short_description   text
  detailed_description text
  tier_version_id     int  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (tier_id, level) [pk] }
}
Ref: tier_level.tier_id        > tier_definition.id         [delete: cascade,  update: cascade]
Ref: tier_level.tier_version_id> version.id      [delete: restrict, update: cascade]
Ref: tier_level.created_by     > user.id [delete: restrict, update: cascade]
Ref: tier_level.updated_by     > user.id [delete: restrict, update: cascade]

Table tier_outcome_link {
  tier_id    int [not null]
  outcome_id int [not null]

  Indexes {
    (tier_id, outcome_id) [pk]
    (outcome_id, tier_id)
  }
}

Ref: tier_outcome_link.tier_id    > tier_definition.id            [delete: restrict, update: cascade]
Ref: tier_outcome_link.outcome_id > outcome_definition.id [delete: restrict, update: cascade]

// Link variable groups to tier definitions
Table tier_variable_group_link {
  tier_id  int [not null]           // FK → tier_definition.id
  group_id int [not null]           // FK → variable_group.id
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]

  Indexes {
    (tier_id, group_id) [pk]
    (group_id, tier_id)
  }
}

Ref: tier_variable_group_link.tier_id    > tier_definition.id [delete: cascade, update: cascade]
Ref: tier_variable_group_link.group_id   > variable_group.id  [delete: cascade, update: cascade]
Ref: tier_variable_group_link.created_by > user.id    [delete: restrict, update: cascade]

//────────────────────────────────────────────
// METADATA SUBTABLES
//────────────────────────────────────────────
Table scenario_metadata {
  id              uuid   [pk]
  scenario_id     int   [not null]
  theme_id        int    [not null]

  study_name      text
  alias           text
  version         text
  url             text
  created         date
  last_modified   date
  raw             jsonb  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { 
    (scenario_id) [unique]
    (study_name) 
    (alias)
    (theme_id, scenario_id) 
  }
}
Ref: scenario_metadata.theme_id    > theme.id      [delete: restrict, update: cascade]
Ref: scenario_metadata.scenario_id > scenario.id   [delete: cascade,  update: restrict]
Ref: scenario_metadata.created_by  > user.id [delete: restrict, update: cascade]
Ref: scenario_metadata.updated_by  > user.id [delete: restrict, update: cascade]

Table scenario_ancillary_output {
  id                   uuid [pk]
  scenario_metadata_id uuid [not null]
  output_type          text
  file_name            text
  metadata_version_id  int  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: scenario_ancillary_output.scenario_metadata_id > scenario_metadata.id [delete: restrict, update: cascade]
Ref: scenario_ancillary_output.metadata_version_id  > version.id           [delete: restrict, update: cascade]
Ref: scenario_ancillary_output.created_by           > user.id     [delete: restrict, update: cascade]
Ref: scenario_ancillary_output.updated_by           > user.id     [delete: restrict, update: cascade]

//────────────────────────────────────────────
//  EXTERNAL MODEL METADATA
//────────────────────────────────────────────
Table model_source {
  id                int   [pk, increment]
  name              text  [unique, not null]
  version_family_id int   [not null]
  description       text
  contact           text
  notes             text

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: model_source.version_family_id > version_family.id [delete: restrict, update: cascade]
Ref: model_source.created_by        > user.id   [delete: restrict, update: cascade]
Ref: model_source.updated_by        > user.id   [delete: restrict, update: cascade]

Table model_variable {
  id                  int   [pk, increment]
  model_source_id     int   [not null]              
  short_code          text  [not null]
  name                text
  unit_id             int
  temporal_scale_id   int   [not null]              // FK → temporal_scale.id (data generation frequency)
  geometry_type_id    int
  description         text
  variable_version_id int   [not null]              

  Indexes { (model_source_id, short_code) [unique] }
}

Ref: model_variable.model_source_id     > model_source.id [delete: restrict, update: cascade]
Ref: model_variable.variable_version_id > version.id      [delete: restrict, update: cascade]
Ref: model_variable.unit_id > unit.id [delete: restrict, update: cascade]
Ref: model_variable.temporal_scale_id > temporal_scale.id [delete: restrict, update: cascade]
Ref: model_variable.geometry_type_id > geometry_type.id [delete: restrict, update: cascade]

Table model_run {
  id              uuid [pk]
  model_source_id int  [not null]
  scenario_id     int [not null]
  run_timestamp   timestamp [not null]
  manifest        jsonb
  notes           text

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (model_source_id, scenario_id, run_timestamp) [unique] }
}
Ref: model_run.model_source_id > model_source.id [delete: restrict, update: cascade]
Ref: model_run.scenario_id     > scenario.id     [delete: restrict, update: cascade]
Ref: model_run.created_by      > user.id [delete: restrict, update: cascade]
Ref: model_run.updated_by      > user.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
//  EXTERNAL MODEL – SCALAR VALUES
//────────────────────────────────────────────

Table model_value {
  id                int     [pk, increment]
  model_run_id      uuid    [not null]
  variable_id       int     [not null]
  geometry_id       uuid
  value             numeric [not null]
  source_version_id int     [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (model_run_id, variable_id, geometry_id) [unique]
    (variable_id, geometry_id)
    (geometry_id)
  }
}
Ref: model_value.model_run_id      > model_run.id      [delete: cascade,  update: cascade]
Ref: model_value.variable_id       > model_variable.id [delete: restrict, update: cascade]
Ref: model_value.geometry_id       > geometry.id       [delete: set null, update: cascade]
Ref: model_value.source_version_id > version.id        [delete: restrict, update: cascade]
Ref: model_value.created_by        > user.id   [delete: restrict, update: cascade]
Ref: model_value.updated_by        > user.id   [delete: restrict, update: cascade]

//────────────────────────────────────────────
// INTERPRETIVE FRAMEWORK
//────────────────────────────────────────────

Table analysis {
  id                     int  [pk, increment]
  name                   text [unique, not null]
  description            text
  analysis_type_id       int
  notes                  text
  interpretive_version_id int [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: analysis.analysis_type_id       > analysis_type.id [delete: restrict, update: cascade]
Ref: analysis.interpretive_version_id> version.id          [delete: restrict, update: cascade]
Ref: analysis.created_by             > user.id     [delete: restrict, update: cascade]
Ref: analysis.updated_by             > user.id     [delete: restrict, update: cascade]

Table key_concept {
  id                     int  [pk, increment]
  name                   text [unique, not null]
  definition             text
  interpretive_version_id int  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: key_concept.interpretive_version_id > version.id      [delete: restrict, update: cascade]
Ref: key_concept.created_by              > user.id [delete: restrict, update: cascade]
Ref: key_concept.updated_by              > user.id [delete: restrict, update: cascade]

Table chart_type {
  id                     int  [pk, increment]
  type                   text [unique, not null]
  interpretive_version_id int  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: chart_type.interpretive_version_id > version.id      [delete: restrict, update: cascade]
Ref: chart_type.created_by              > user.id [delete: restrict, update: cascade]
Ref: chart_type.updated_by              > user.id [delete: restrict, update: cascade]

Table ancillary_data {
  id                       int  [pk, increment]
  name                     text [unique, not null]
  data                     json
  description              text
  source                   text
  interpretive_version_id  int  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: ancillary_data.interpretive_version_id > version.id      [delete: restrict, update: cascade]
Ref: ancillary_data.created_by              > user.id [delete: restrict, update: cascade]
Ref: ancillary_data.updated_by              > user.id [delete: restrict, update: cascade]

Table theme_key_concept_link {
  theme_id       int [not null]
  key_concept_id int [not null]

  Indexes {
    (theme_id, key_concept_id) [pk]
    (key_concept_id, theme_id)
  }
}

Ref: theme_key_concept_link.theme_id       > theme.id       [delete: restrict, update: cascade]
Ref: theme_key_concept_link.key_concept_id > key_concept.id [delete: restrict, update: cascade]

Table theme_chart_type_link {
  theme_id     int [not null]
  chart_type_id int [not null]

  Indexes {
    (theme_id, chart_type_id) [pk]
    (chart_type_id, theme_id)
  }
}

Ref: theme_chart_type_link.theme_id     > theme.id     [delete: restrict, update: cascade]
Ref: theme_chart_type_link.chart_type_id > chart_type.id [delete: restrict, update: cascade]

Table theme_ancillary_data_link {
  theme_id          int [not null]
  ancillary_data_id int [not null]

  Indexes {
    (theme_id, ancillary_data_id) [pk]
    (ancillary_data_id, theme_id)
  }
}

Ref: theme_ancillary_data_link.theme_id          > theme.id          [delete: restrict, update: cascade]
Ref: theme_ancillary_data_link.ancillary_data_id > ancillary_data.id [delete: restrict, update: cascade]

Table theme_analysis_link {
  theme_id    int [not null]
  analysis_id int [not null]

  Indexes {
    (theme_id, analysis_id) [pk]
    (analysis_id, theme_id)
  }
}

Ref: theme_analysis_link.theme_id    > theme.id    [delete: restrict, update: cascade]
Ref: theme_analysis_link.analysis_id > analysis.id [delete: restrict, update: cascade]

// Link themes to variable groups (what variables are key for each theme)
Table theme_variable_group_link {
  theme_id int [not null]           // FK → theme.id
  group_id int [not null]           // FK → variable_group.id
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]

  Indexes {
    (theme_id, group_id) [pk]
    (group_id, theme_id)
  }
}

Ref: theme_variable_group_link.theme_id    > theme.id         [delete: cascade, update: cascade]
Ref: theme_variable_group_link.group_id    > variable_group.id [delete: cascade, update: cascade]
Ref: theme_variable_group_link.created_by  > user.id  [delete: restrict, update: cascade]

//────────────────────────────────────────────
// GEOMETRY & CONSTANTS
//────────────────────────────────────────────
Table geometry {
  id                 uuid   [pk]
  name               text
  geometry_type_id   int    [not null]        // FK → geometry_type.id
  geom               geometry(Geometry,4326)
  geometries_version_id int [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (geom) [type: gist] }
}

Ref: geometry.geometry_type_id       > geometry_type.id [delete: restrict, update: cascade]
Ref: geometry.geometries_version_id  > version.id          [delete: restrict, update: cascade]
Ref: geometry.created_by             > user.id     [delete: restrict, update: cascade]
Ref: geometry.updated_by             > user.id     [delete: restrict, update: cascade]

Table geometry_lookup {
  id            uuid   [pk]
  geometry_id   uuid   [not null]
  variable_id   uuid   [not null]
  attribute_name text
  value         numeric

  Indexes {
    (geometry_id)
    (variable_id)
  }
}

Ref: geometry_lookup.geometry_id > geometry.id [delete: cascade, update: cascade]

Table node {
  id              uuid [pk]
  name            text
  geometry_type_id int  // null-able
  geom            geometry(Point,4326) [not null]

  Indexes { (geom) [type: gist] }
}

Ref: node.geometry_type_id > geometry_type.id [delete: restrict, update: cascade]

Table arc {
  id              uuid [pk]
  from_node_id    uuid [not null, ref: > node.id]
  to_node_id      uuid [not null, ref: > node.id]
  geometry_type_id int  // optional
  geom            geometry(LineString,4326) [not null]
  metadata        json

  Indexes {
    (from_node_id)
    (to_node_id)
    (geom) [type: gist]
  }
}

Ref: arc.geometry_type_id > geometry_type.id [delete: restrict, update: cascade]

Table geometry_attributes_node {
  id                  uuid   [pk]
  geometry_id         uuid   [not null]
  sub_type            text
  region_id           int
  shape_length        numeric
  Indexes { (geometry_id) [unique] }
}

Ref: geometry_attributes_node.geometry_id > geometry.id [delete: cascade, update: restrict]
Ref: geometry_attributes_node.region_id > region.id [delete: restrict, update: cascade]

Table geometry_attributes_arc {
  id                 uuid   [pk]
  geometry_id        uuid   [not null]
  arc_description    text
  from_node          text
  to_node            text
  shape_length       numeric
  Indexes { (geometry_id) [unique] }
}

Ref: geometry_attributes_arc.geometry_id > geometry.id [delete: cascade, update: restrict]

Table geometry_attributes_demand_unit {
  id           uuid   [pk]
  geometry_id  uuid   [not null]
  crop_type    text
  region_id    int
  area_ha      numeric
  Indexes { (geometry_id) [unique] }
}

Ref: geometry_attributes_demand_unit.geometry_id > geometry.id [delete: cascade, update: restrict]
Ref: geometry_attributes_demand_unit.region_id > region.id [delete: restrict, update: cascade]

Table constant {
  id                   uuid   [pk]
  label                text
  year                 int
  value                text
  source               text
  metadata_version_id  int    [not null]
  Indexes { (label, year) [unique] }
}

Ref: constant.metadata_version_id > version.id [delete: restrict, update: cascade]

// NOTE: Time series data stored in S3 - see scenario_timeseries_file table for metadata

//────────────────────────────────────────────
// SCENARIO OUTCOME RESULTS (AGGREGATES)
//────────────────────────────────────────────
Table scenario_outcome_value {
  scenario_id int  [not null, ref: > scenario.id]
  outcome_id  int   [not null, ref: > outcome_definition.id]
  geometry_id uuid  [ref: > geometry.id]
  time_period      text                        
  stat        statistic_type [not null]
  value       numeric      [not null]
  created_at  timestamp    [default: "now()"]

  Indexes {
    (scenario_id, outcome_id, geometry_id, time_period, stat) [unique]
  }
}

Table scenario_tier_value {
  scenario_id   int  [ref: > scenario.id]
  outcome_id    int   [ref: > outcome_definition.id, note: 'NULL → row is for variable']
  variable_id   uuid  [note: 'NULL → row is for outcome']
  tier_id       int   [not null, ref: > tier_definition.id]
  level         int   [not null, note: '1-4']
  geometry_id   uuid  [ref: > geometry.id]
  time_period   text  [not null]

  source_version_id int  [not null, ref: > version.id]
  created_by  int [not null, ref: > user.id]
  created_at        timestamp [default: "now()"]
  updated_at        timestamp

  Note: 'CHECK ( (outcome_id IS NOT NULL)::int + (variable_id IS NOT NULL)::int = 1 )'

  Indexes {
    // Composite "business key" (acts as PK in dbdiagram)
    (scenario_id, outcome_id, variable_id, tier_id, geometry_id, time_period) [pk]

    // Helper indexes (had to write the WHERE in a note so DBML parses)
    (scenario_id, outcome_id)  [note: 'Postgres partial index WHERE outcome_id IS NOT NULL']
    (scenario_id, variable_id) [note: 'Postgres partial index WHERE variable_id IS NOT NULL']
  }
}

//────────────────────────────────────────────
//  CO‑BENEFITS / TRADE‑OFFS / LARGE DELTAS
//────────────────────────────────────────────

Table scenario_outcome_delta {
  id                     int   [pk, increment]

  scenario_id            int  [not null, ref: > scenario.id]
  baseline_scenario_id   int  [not null, ref: > scenario.id]
  outcome_id             int   [not null, ref: > outcome_definition.id]

  stat                   text         
  value                  numeric     

  analysis_type_id       int
  rationale              text        
  significance_flag      boolean       // TRUE = flagged as "key" in dashboards

  created_at             timestamp [default: "now()"]

  Indexes {
    (scenario_id, outcome_id, stat) [unique]   
    (analysis_type_id)
  }
}

Ref: scenario_outcome_delta.analysis_type_id > analysis_type.id [delete: restrict, update: cascade]

Table analysis_result_delta {
  analysis_id int [not null]
  delta_id    int [not null]

  Indexes { (analysis_id, delta_id) [pk] }
}

Ref: analysis_result_delta.analysis_id > analysis.id [delete: cascade, update: cascade]
Ref: analysis_result_delta.delta_id > scenario_outcome_delta.id [delete: cascade, update: cascade]



//────────────────────────────────────────────
// RING-BASED CALSIM ARCHITECTURE!
//────────────────────────────────────────────

//═══════════════════════════════════════════════
// RING 1: GRAPH CORE (Network Topology)
// Single Source: CS3_NetworkSchematic_Integrated_11.28.23.xml
//═══════════════════════════════════════════════

// Node type lookup table for consistency across models
Table network_node_type {
  id                   int  [pk, increment]
  short_code           text [not null, unique]        // 'reservoir', 'habitat_node', 'junction', 'treatment_plant', 'diversion'
  name                 text [not null]                // 'Reservoir Node', 'Habitat Node', 'Junction', 'Treatment Plant'
  description          text
  model_source_id      int                            // FK → model_source.id (NULL = generic/cross-model)
  is_active            boolean [not null, default: true]
  
  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp
  updated_by  int

  Indexes {
    (short_code) [unique]
    (model_source_id)
    (is_active, model_source_id)
  }

  Note: 'Node types supporting multiple models'
}

Ref: network_node_type.created_by > user.id [delete: restrict, update: cascade]
Ref: network_node_type.updated_by > user.id [delete: restrict, update: cascade]
Ref: network_node_type.model_source_id > model_source.id [delete: restrict, update: cascade]

// Arc type lookup table for consistency across models
Table network_arc_type {
  id                   int  [pk, increment]
  short_code           text [not null, unique]        // 'calsim_inflow', 'riparian_flow', 'socal_import', 'cross_model_boundary'
  name                 text [not null]                // 'CalSim Inflow Arc', 'Riparian Flow Connection', 'Cross-Model Boundary'
  description          text
  model_source_id      int                            // FK → model_source.id (NULL = generic/cross-model)
  is_cross_model       boolean [default: false]       // TRUE for arcs connecting different models
  flow_direction       text [default: 'unidirectional'] // 'unidirectional', 'bidirectional', 'variable'
  is_active            boolean [not null, default: true]
  
  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp
  updated_by  int

  Indexes {
    (short_code) [unique]
    (model_source_id)
    (is_cross_model)
    (is_active, model_source_id)
  }

  Note: 'Arc types supporting multiple models and cross-model connections'
}

Ref: network_arc_type.created_by > user.id [delete: restrict, update: cascade]
Ref: network_arc_type.updated_by > user.id [delete: restrict, update: cascade]
Ref: network_arc_type.model_source_id > model_source.id [delete: restrict, update: cascade]



// SCHEMA: network
// Core network topology tables organized under network schema
Table network.node {
  id                   int    [pk, increment]
  short_code           text   [not null]              // 'SHSTA', 'RIP_SAC_01', 'SOCAL_MWD_12'
  node_type_id         int    [not null]              // FK → network_node_type.id
  name                 text                           // Human-readable name from model source
  description          text                           // Description from model source or domain knowledge
  
  // Multi-model identification
  model_source_id      int    [not null]              // FK → model_source.id ('calsim3', 'riparian', etc.)
  model_node_id        text                           // Original node ID from source model
  diagram_id           int                            // Source diagram reference (for models with diagrams)
  
  // Cross-model integration
  parent_node_id       int                            // FK → network.node.id (for model hierarchies)
  equivalent_nodes     int[]                          // Array of equivalent node IDs from other models
  integration_status   text   [default: 'active']     // 'active', 'deprecated', 'merged', 'conflicted'
  
  // Spatial and model-specific attributes
  geom                 geometry(Point,4326)           // Spatial location if available
  model_attributes     jsonb                          // Model-specific attributes as JSON
  
  // Versioning and source tracking
  network_version_id   int    [not null]              // FK → version.id (network topology version)
  source_ids           int[]  [not null]              // Array of source IDs from multiple models
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (network_version_id, short_code) [unique]          // Composite unique constraint - no duplicate names per version
    (model_source_id, model_node_id) [unique]          // Unique within each model
    (diagram_id)                                       // Authoritative diagram reference
    (node_type_id, model_source_id)                    // Find nodes by type within model
    (parent_node_id)                                   // Hierarchical queries
    (equivalent_nodes) [type: gin]                     // Cross-model equivalence queries
    (integration_status)                               // Find integration issues
    (network_version_id)                               // Version-specific queries
    (source_ids) [type: gin]                           // GIN index for array operations on sources
    (geom) [type: gist]                                // GIST index for spatial queries
    (model_attributes) [type: gin]                     // JSON attribute search
  }

  Note: '''
    Multi-model network nodes supporting CalSim3, riparian models, SoCal systems, etc.
    CHECK (integration_status IN ('active', 'deprecated', 'merged', 'conflicted'))
  '''
}

Table network.arc {
  id                   int    [pk, increment]
  short_code           text   [not null]              // 'I_SHSTA', 'RIP_FLOW_01', 'SOCAL_IMPORT_12'
  arc_type_id          int    [not null]              // FK → network_arc_type.id
  name                 text                           // Human-readable name from model source
  description          text                           // Description from model source or domain knowledge
  
  // Multi-model identification
  model_source_id      int    [not null]              // FK → model_source.id ('calsim3', 'riparian', etc.)
  model_arc_id         text                           // Original arc ID from source model
  diagram_id           int                            // Source diagram reference (for models with diagrams)
  
  // Network topology - THE definitive connections
  from_node_id         int                            // FK → network.node.id (nullable for boundary inflows)
  to_node_id           int    [not null]              // FK → network.node.id (all arcs must terminate)
  
  // Directional flow properties
  is_reversible        boolean [not null, default: false] // TRUE if flow can go both directions
  flow_capacity        numeric                        // Maximum flow capacity (if applicable)
  
  // Cross-model integration
  parent_arc_id        int                            // FK → network.arc.id (for model hierarchies)
  equivalent_arcs      int[]                          // Array of equivalent arc IDs from other models
  integration_status   text   [default: 'active']     // 'active', 'deprecated', 'merged', 'conflicted'
  
  // Spatial and model-specific attributes
  geom                 geometry(LineString,4326)      // Spatial path if available
  model_attributes     jsonb                          // Model-specific attributes as JSON
  
  // Versioning and source tracking
  network_version_id   int    [not null]              // FK → version.id (network topology version)
  source_ids           int[]  [not null]              // Array of source IDs from multiple models
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (network_version_id, short_code) [unique]          // Composite unique constraint - no duplicate names per version
    (model_source_id, model_arc_id) [unique]           // Unique within each model
    (diagram_id)                                       // Authoritative diagram reference
    (arc_type_id, model_source_id)                     // Find arcs by type within model
    (from_node_id, model_source_id)                    // Model-specific topology queries
    (to_node_id, model_source_id)                      // Model-specific topology queries
    (parent_arc_id)                                    // Hierarchical queries
    (equivalent_arcs) [type: gin]                      // Cross-model equivalence queries
    (integration_status)                               // Find integration issues
    (network_version_id)                               // Version-specific queries
    (source_ids) [type: gin]                           // GIN index for array operations on sources
    (geom) [type: gist]                                // GIST index for spatial queries
    (is_reversible)                                    // Find reversible arcs
    (model_attributes) [type: gin]                     // JSON attribute search
  }

  Note: '''
    Multi-model network arcs supporting CalSim3, riparian models, SoCal systems, etc.
    CHECK (integration_status IN ('active', 'deprecated', 'merged', 'conflicted'))
  '''
}

// Extension table for variable node attributes (key-value pattern)
Table network.node_attributes {
  id          int  [pk, increment]
  node_id     int  [not null]                         // FK → network.node.id
  attr_key    text [not null]                         // 'outlet_type', 'flow_split_ratio', 'demand_priority'
  attr_value  text [not null]                         // Attribute value as text
  data_type   text [not null, default: 'text']        // 'text', 'numeric', 'boolean', 'json'
  
  // Versioning
  network_version_id int [not null]                   // FK → version.id (must match node's version)
  
  // Standard metadata
  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp
  updated_by  int

  Indexes {
    (node_id, attr_key) [unique]                       // One value per key per node
    (attr_key)                                         // Find all nodes with specific attribute
    (network_version_id)                               // Version-specific queries
    (node_id)                                          // All attributes for a node
  }

  Note: 'Extension table for variable node attributes discovered in XML or added through domain knowledge'
}

// Foreign key relationships for Ring 1 (Multi-Model)
Ref: network.arc.from_node_id > network.node.id [delete: restrict, update: cascade]
Ref: network.arc.to_node_id   > network.node.id [delete: restrict, update: cascade]
Ref: network.arc.arc_type_id  > network_arc_type.id [delete: restrict, update: cascade]
Ref: network.node.node_type_id > network_node_type.id [delete: restrict, update: cascade]
Ref: network.arc.parent_arc_id > network.arc.id [delete: set null, update: cascade]
Ref: network.node.parent_node_id > network.node.id [delete: set null, update: cascade]
Ref: network.node.model_source_id > model_source.id [delete: restrict, update: cascade]
Ref: network.arc.model_source_id > model_source.id [delete: restrict, update: cascade]
Ref: network.node.network_version_id > version.id [delete: restrict, update: cascade]
Ref: network.arc.network_version_id  > version.id [delete: restrict, update: cascade]
Ref: network.node_attributes.node_id > network.node.id [delete: cascade, update: cascade]
Ref: network.node_attributes.network_version_id > version.id [delete: restrict, update: cascade]
Ref: network.node.created_by > user.id [delete: restrict, update: cascade]
Ref: network.node.updated_by > user.id [delete: restrict, update: cascade]
Ref: network.arc.created_by  > user.id [delete: restrict, update: cascade]
Ref: network.arc.updated_by  > user.id [delete: restrict, update: cascade]
Ref: network.node_attributes.created_by > user.id [delete: restrict, update: cascade]
Ref: network.node_attributes.updated_by > user.id [delete: restrict, update: cascade]

//═══════════════════════════════════════════════
// RING 2: ENTITY VIEWS (Domain-Specific Rich Data)
// Multiple Sources: CalSim reports, domain expertise, GIS data
//═══════════════════════════════════════════════

Table reservoir_entity {
  id                   int    [pk, increment]
  network_node_id      int    [not null, unique]      // FK → network.node.id (Ring 1 reference)
  
  // Domain-derived identifiers (for convenience and legacy compatibility)
  short_code           text   [not null, unique]      // 'SHSTA', 'OROVL', 'FOLSM' (derived from network.node)
  name                 text   [not null]              // 'Shasta Reservoir', 'Lake Oroville'
  description          text                           // Detailed description from domain sources
  associated_river     text                           // 'Sacramento River', 'Feather River'
  
  // Legacy CalSim classifications (may be deprecated in favor of Ring 1)
  entity_type_id       int    [not null]              // FK → calsim_entity_type.id (currently "reservoir")
  schematic_type_id    int    [not null]              // FK → calsim_schematic_type.id (currently "node")

  
  // Regional classification
  hydrologic_region_id int                            // FK → hydrologic_region.id (SAC, SJR)
  
  // Rich physical characteristics (domain expertise)
  capacity_taf         numeric                        // Total capacity in TAF
  dead_pool_taf        numeric                        // Dead pool storage in TAF
  surface_area_acres   numeric                        // Surface area in acres
  operational_purpose  text                           // 'water_supply', 'flood_control', 'power_generation', 'water_quality', 'regulating', 'afterbay'
  
  // Domain-specific flags and attributes
  has_gis_data         boolean [default: false]       // Whether entity has spatial/geographic data
  has_tiers            boolean [not null, default: false]  // TRUE for reservoirs with tier classifications
  is_main              boolean [not null, default: false]  // TRUE for main/primary reservoirs in system
  
  // Versioning and source tracking (domain data, not network)
  entity_version_id    int    [not null]              // FK → version.id (domain entity data version)
  source_ids           int[]  [not null]              // Array of domain source IDs (reports, GIS, etc.)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (network_node_id) [unique]                         // One-to-one with network node
    (short_code) [unique]                              // Domain lookup
    (entity_version_id, short_code) [unique]           // Ensure unique short_code within each version
    (hydrologic_region_id)                             // Regional queries
    (hydrologic_region_id, entity_type_id) [note: 'Composite index for common queries']
    (has_gis_data)                                     // Find reservoirs with/without GIS data
    (has_tiers)                                        // Find tier reservoirs
    (is_main)                                          // Find main reservoirs
    (associated_river)                                 // Find reservoirs by river
    (operational_purpose)                              // Find reservoirs by operational purpose
    (entity_version_id)                                // Find entities by version
    (source_ids) [type: gin]                           // GIN index for array operations on source IDs
  }

  Note: '''
    Rich domain-specific data for reservoir entities. References Ring 1 network topology.
    CHECK (capacity_taf >= 0)
    CHECK (dead_pool_taf >= 0 AND dead_pool_taf <= capacity_taf)
  '''
}

// Foreign key relationships for Ring 2 - Reservoir Entity
Ref: reservoir_entity.network_node_id      > network.node.id [delete: restrict, update: cascade]
Ref: reservoir_entity.entity_type_id       > calsim_entity_type.id [delete: restrict, update: cascade]
Ref: reservoir_entity.schematic_type_id    > calsim_schematic_type.id [delete: restrict, update: cascade]
Ref: reservoir_entity.hydrologic_region_id > hydrologic_region.id  [delete: restrict, update: cascade]
Ref: reservoir_entity.entity_version_id    > version.id        [delete: restrict, update: cascade]
Ref: reservoir_entity.created_by           > user.id          [delete: restrict, update: cascade]
Ref: reservoir_entity.updated_by           > user.id          [delete: restrict, update: cascade]

Table inflow_entity {
  id                   int    [pk, increment]
  network_arc_id       int    [not null, unique]      // FK → network.arc.id (Ring 1 reference)
  
  // Domain-derived identifiers (for convenience and legacy compatibility)
  short_code           text   [not null, unique]      // 'I_SHSTA', 'I_OROVL', 'I_FOLSM' (derived from network.arc)
  name                 text   [not null]              // 'Shasta Lake Inflow', 'Lake Oroville Inflow'
  description          text                           // Detailed description from CalSim manual
  
  // Domain-specific inflow attributes
  to_node              text   [not null]              // Downstream node ID where inflow enters (legacy field)
  has_gis_data         boolean [default: false]       // Whether entity has spatial/geographic data
  
  // Legacy CalSim classifications (may be deprecated in favor of Ring 1)
  entity_type_id       int    [not null]              // FK → calsim_entity_type.id (currently "inflow")
  schematic_type_id    int    [not null]              // FK → calsim_schematic_type.id (currently "arc")
  
  // Regional classification
  hydrologic_region_id int                            // FK → hydrologic_region.id (SAC, SJR)
  
  // Versioning and source tracking (domain data, not network)
  entity_version_id    int    [not null]              // FK → version.id (domain entity data version)
  source_ids           int[]  [not null]              // Array of domain source IDs (reports, CalSim data, etc.)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (network_arc_id) [unique]                          // One-to-one with network arc
    (short_code) [unique]                              // Primary domain lookup
    (entity_version_id, short_code) [unique]           // Ensure unique short_code within each version
    (to_node)                                          // Find inflows by destination node
    (entity_type_id)                                   // Find inflows by entity type
    (schematic_type_id)                                // Find inflows by schematic type
    (hydrologic_region_id)                             // Find inflows by region
    (has_gis_data)                                     // Find inflows with/without GIS data
    (entity_version_id)                                // Find entities by version
    (source_ids) [type: gin]                           // GIN index for array operations on source IDs
  }

  Note: 'Rich domain-specific data for inflow entities. References Ring 1 network topology.'
}

// Foreign key relationships for Ring 2 - Inflow Entity
Ref: inflow_entity.network_arc_id       > network.arc.id [delete: restrict, update: cascade]
Ref: inflow_entity.entity_type_id       > calsim_entity_type.id [delete: restrict, update: cascade]
Ref: inflow_entity.schematic_type_id    > calsim_schematic_type.id [delete: restrict, update: cascade]
Ref: inflow_entity.hydrologic_region_id > hydrologic_region.id [delete: restrict, update: cascade]
Ref: inflow_entity.entity_version_id    > version.id        [delete: restrict, update: cascade]
Ref: inflow_entity.created_by           > user.id          [delete: restrict, update: cascade]
Ref: inflow_entity.updated_by           > user.id          [delete: restrict, update: cascade]

Table channel_entity {
  id                   int    [pk, increment]
  network_arc_id       int    [not null, unique]      // FK → network.arc.id (Ring 1 reference)
  
  // Domain-derived identifiers (for convenience and legacy compatibility)
  short_code           text   [not null, unique]      // 'C_SAC123', 'C_SJR456', 'C_AMR015' (derived from network.arc)
  name                 text   [not null]              // 'Sacramento River Section 123', 'American River'
  description          text                           // Detailed description from domain sources
  
  // Domain-specific channel attributes
  subtype              text                           // 'Stream', 'Canal', 'Bypass', 'Aqueduct'
  boundary_condition   text                           // From Central Valley Modeling doc
  from_node            text                           // Upstream node ID (legacy field)
  to_node              text                           // Downstream node ID (legacy field)
  
  // Physical characteristics
  length_m             numeric                        // Length in meters from GIS
  
  // Domain-specific flags and attributes
  has_tiers            boolean [not null, default: false]  // TRUE for channels with tier classifications
  is_main              boolean [not null, default: false]  // TRUE for main/primary channels in system
  has_gis_data         boolean [default: false]       // Whether variable has GIS data
  naming_convention    text                           // Naming convention pattern
  naming_prefix        text                           // Prefix extracted from calsim_id (e.g. "SAC", "AMR")
  
  // Legacy CalSim classifications (may be deprecated in favor of Ring 1)
  entity_type_id       int    [not null]              // FK → calsim_entity_type.id (currently "channel")
  schematic_type_id    int    [not null]              // FK → calsim_schematic_type.id (currently "arc")
  
  // Regional classification
  hydrologic_region_id int                            // FK → hydrologic_region.id
  
  // Versioning and source tracking (domain data, not network)
  entity_version_id    int    [not null]              // FK → version.id (domain entity data version)
  source_ids           int[]  [not null]              // Array of domain source IDs (reports, GIS, etc.)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (network_arc_id) [unique]                          // One-to-one with network arc
    (short_code) [unique]                              // Primary domain lookup
    (entity_version_id, short_code) [unique]           // Ensure unique short_code within each version
    (entity_type_id)                                   // Find channels by entity type
    (schematic_type_id)                                // Find channels by schematic type
    (hydrologic_region_id)                             // Regional queries
    (naming_prefix)                                    // Find channels by naming pattern
    (has_gis_data)                                     // Find channels with/without GIS data
    (subtype)                                          // Find channels by subtype
    (from_node)                                        // Legacy topology queries
    (to_node)                                          // Legacy topology queries
    (entity_version_id)                                // Find entities by version
    (source_ids) [type: gin]                           // GIN index for array operations on source IDs
  }

  Note: 'Rich domain-specific data for channel entities. References Ring 1 network topology.'
}

// Foreign key relationships for Ring 2 - Channel Entity
Ref: channel_entity.network_arc_id       > network.arc.id [delete: restrict, update: cascade]
Ref: channel_entity.entity_type_id       > calsim_entity_type.id [delete: restrict, update: cascade]
Ref: channel_entity.schematic_type_id    > calsim_schematic_type.id [delete: restrict, update: cascade]
Ref: channel_entity.hydrologic_region_id > hydrologic_region.id [delete: restrict, update: cascade]
Ref: channel_entity.entity_version_id    > version.id        [delete: restrict, update: cascade]
Ref: channel_entity.created_by           > user.id          [delete: restrict, update: cascade]
Ref: channel_entity.updated_by           > user.id          [delete: restrict, update: cascade]

//═══════════════════════════════════════════════
// RING 2: VARIABLE TABLES (Domain-Specific Variable Data)
// Multiple Sources: CalSim variables, reports, operational documents
//═══════════════════════════════════════════════

Table reservoir_variable {
  id                   int    [pk, increment]
  calsim_id            text   [not null, unique]      // 'S_SHSTA', 'S_SHSTA_1', 'S_SHSTA_2'
  name                 text   [not null]              // 'Shasta Total Storage', 'Shasta Flood Control Zone'
  description          text                           // Detailed description
  
  // Link to reservoir entity
  reservoir_entity_id  int    [not null]              // FK → reservoir_entity.id
  primary_entity_short_code text                      // Short code of primary entity this variable represents
  
  // Variable classification
  variable_type        text   [not null]              // 'storage_level', 'storage_zone', 'decision', 'state'
  storage_zone_type    text                           // 'total', 'flood_control', 'conservation', 'dead_pool', 'delta_reserve', 'carryover'
  operational_purpose  text                           // 'water_supply', 'flood_control', 'power_generation', 'water_quality'
  
  // Aggregation attributes
  is_aggregate         boolean [default: false]       // TRUE for variables that aggregate multiple reservoirs
  aggregated_variable_ids  uuid[]                     // Array of variable IDs that this variable aggregates
  
  // Operational thresholds
  trigger_threshold    numeric                        // Threshold value for operational triggers (e.g., 500 TAF)
  
  // Linkage and metadata
  unit_id              int                            // FK → unit.id
  temporal_scale_id    int                            // FK → temporal_scale.id (monthly, daily, etc.)
  variable_id           uuid
  variable_version_id  int    [not null]              // FK → version.id
  
  // Source tracking
  source_ids           int[]  [not null]              // Array of source IDs (FK → source.id)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at           timestamp
  updated_by  int

  Indexes {
    (calsim_id) [unique]
    (reservoir_entity_id)                             // Find all variables for a reservoir
    (variable_type)                                   // Find variables by type (storage_level, storage_zone, etc.)
    (storage_zone_type)                               // Find variables by storage zone
    (operational_purpose)                             // Find variables by operational purpose
    (is_aggregate)                                    // Find aggregate variables
    (aggregated_variable_ids) [type: gin]            // GIN index for array operations on aggregated variables
    (source_ids) [type: gin]                          // GIN index for array operations on source IDs
  }

  Note: 'Storage and operational variables associated with reservoir entities'
}

Ref: reservoir_variable.reservoir_entity_id > reservoir_entity.id     [delete: cascade, update: cascade]
Ref: reservoir_variable.unit_id             > unit.id                 [delete: restrict, update: cascade]
Ref: reservoir_variable.variable_version_id > version.id                 [delete: restrict, update: cascade]
Ref: reservoir_variable.created_by          > user.id          [delete: restrict, update: cascade]
Ref: reservoir_variable.updated_by          > user.id          [delete: restrict, update: cascade]
Ref: reservoir_variable.temporal_scale_id      > temporal_scale.id    [delete: restrict, update: cascade]


Table inflow_variable {
  id                   int    [pk, increment]
  calsim_id            text   [not null, unique]      // 'I_SHSTA', 'I_OROVL', 'I_FOLSM'
  name                 text   [not null]              // 'Shasta Lake inflow rate'
  description          text                           // Detailed description from CalSim manual
  
  // Link to Ring 2 inflow entity
  inflow_entity_id     int    [not null]              // FK → inflow_entity.id
  
  // Variable classification (domain expertise)
  variable_type        text   [not null]              // 'inflow_rate', 'historical_inflow', 'projected_inflow'
  
  // Technical attributes
  unit_id              int                            // FK → unit.id (typically CFS)
  temporal_scale_id    int                            // FK → temporal_scale.id (monthly, daily, etc.)
  variable_id          uuid                           // Universal variable identifier
  variable_version_id  int    [not null]              // FK → version.id
  
  // Aggregation attributes
  is_aggregate         boolean [default: false]       // TRUE for variables that aggregate multiple inflows
  aggregated_variable_ids  uuid[]                     // Array of inflow variable IDs that this variable aggregates
  
  // Source tracking (domain variable data)
  source_ids           int[]  [not null]              // Array of source IDs (CalSim variables, reports, etc.)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (calsim_id) [unique]                              // Primary CalSim3 lookup
    (inflow_entity_id)                                // Find variables for an inflow entity
    (variable_type)                                   // Find variables by type
    (variable_id) [unique]                            // Link to main variable system (one-to-one)
    (is_aggregate)                                    // Find aggregate variables
    (aggregated_variable_ids) [type: gin]             // GIN index for array operations on aggregated variables
    (source_ids) [type: gin]                          // GIN index for array operations on source IDs
  }

  Note: 'Inflow rate variables (I_*) that measure water inputs to the system'
}

// Foreign key relationships for Ring 2 - Inflow Variable
Ref: inflow_variable.inflow_entity_id       > inflow_entity.id     [delete: cascade, update: cascade]
Ref: inflow_variable.unit_id                > unit.id              [delete: restrict, update: cascade]
Ref: inflow_variable.temporal_scale_id      > temporal_scale.id    [delete: restrict, update: cascade]
Ref: inflow_variable.variable_version_id    > version.id              [delete: restrict, update: cascade]
Ref: inflow_variable.created_by             > user.id          [delete: restrict, update: cascade]
Ref: inflow_variable.updated_by             > user.id          [delete: restrict, update: cascade]

Table channel_variable {
  id                   int    [pk, increment]
  calsim_id            text   [not null, unique]      // 'C_SAC123', 'UI_SAC123', 'MF_SAC123'
  name                 text   [not null]              // 'Sacramento River flow', 'Sacramento River unimpaired flow'
  description          text                           
  
  // Link to Ring 2 channel entity
  channel_entity_id    int    [not null]              // FK → channel_entity.id
  
  // Variable classification - CRITICAL FOR DOMAIN ANALYSIS
  variable_type        text   [not null]              // 'flow', 'unimpaired_flow', 'minimum_flow'
  
  // Technical attributes
  unit_id              int                            // FK → unit.id (typically CFS)
  temporal_scale_id    int                            // FK → temporal_scale.id (monthly, daily, etc.)
  variable_id          uuid                           // Universal variable identifier
  variable_version_id  int    [not null]              // FK → version.id
  
  // Regulatory/operational (domain expertise)
  is_regulatory        boolean [default: false]       // TRUE for minimum instream flow requirements
  regulatory_authority text                           // Agency setting the requirement

  // Aggregation attributes
  is_aggregate         boolean [default: false]       // TRUE for variables that aggregate multiple channels
  aggregated_variable_ids  uuid[]                     // Array of channel variable IDs that this variable aggregates 
  
  // Linkage to outcomes
  outcome_category_short_code text                    // FK reference to outcome_category
  
  // Source tracking (domain variable data)
  source_ids           int[]  [not null]              // Array of source IDs (CalSim variables, reports, etc.)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (calsim_id) [unique]                              // Primary CalSim3 lookup
    (channel_entity_id)                               // Find variables for a channel entity
    (variable_type)                                   // Find by type: flow, unimpaired_flow, minimum_flow
    (is_regulatory)                                   // Find regulatory requirements
    (is_aggregate)                                    // Find aggregate variables
    (aggregated_variable_ids) [type: gin]             // GIN index for array operations on aggregated variables
    (variable_id)                                     // Link to main variable system
    (source_ids) [type: gin]                          // GIN index for array operations on source IDs
  }

  Note: 'Flow variables for channels including scenario flow, unimpaired flow, and minimum instream flow'
}

// Foreign key relationships for Ring 2 - Channel Variable
Ref: channel_variable.channel_entity_id     > channel_entity.id    [delete: cascade, update: cascade]
Ref: channel_variable.unit_id               > unit.id              [delete: restrict, update: cascade]
Ref: channel_variable.temporal_scale_id     > temporal_scale.id    [delete: restrict, update: cascade]
Ref: channel_variable.variable_version_id   > version.id              [delete: restrict, update: cascade]
Ref: channel_variable.created_by            > user.id          [delete: restrict, update: cascade]
Ref: channel_variable.updated_by            > user.id          [delete: restrict, update: cascade]

Table derived_variable_type {
  id          int  [pk, increment]
  short_code  text [not null, unique]           // 'system_aggregate', 'regional_summary', 'delta_variable', 'environmental_indicator'
  name        text [not null]                   // 'System Aggregate', 'Regional Summary', 'Delta Variable'
  description text
  is_active   boolean [not null, default: true]
  
  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp
  updated_by  int

  Indexes {
    (short_code) [unique]
    (is_active, short_code)
  }

  Note: 'Types of derived variables for categorization and analysis'
}

Ref: derived_variable_type.created_by > user.id [delete: restrict, update: cascade]
Ref: derived_variable_type.updated_by > user.id [delete: restrict, update: cascade]

Table derived_variable {
  id                   int    [pk, increment]
  calsim_id            text   [not null, unique]      // 'NDO', 'X2', etc.
  name                 text   [not null]              // 'net Delta outflow', 'salinity X2 position', etc.
  description          text                           
  
  // Variable classification - NOT tied to specific network elements
  variable_type_id     int    [not null]              // FK → derived_variable_type.id
  system_scope         text                           // 'statewide', 'delta', 'cvp_system', 'swp_system', 'regional'
  calculation_method   text                           // 'sum_of_components', 'spatial_interpolation', 'regulatory_formula'
  
  // Spatial/regional context (not specific nodes/arcs)
  hydrologic_region_id int                            // FK → hydrologic_region.id (regional context)
  spatial_description  text                           // 'Delta boundary', 'Sacramento-San Joaquin confluence', 'CVP service area'
  
  // Technical attributes  
  unit_id              int                            // FK → unit.id (psu for salinity, cfs for flows, etc.)
  temporal_scale_id    int                            // FK → temporal_scale.id (monthly, daily, etc.)
  variable_id          uuid                           // Universal variable identifier
  variable_version_id  int    [not null]              // FK → version.id
  
  // Component relationships (for aggregate variables)
  is_aggregate         boolean [default: false]       // TRUE for variables that aggregate multiple components
  component_variable_ids  uuid[]                      // Array of variable IDs that contribute to this derived variable
  aggregation_rule     text                           // 'sum', 'weighted_average', 'minimum', 'maximum', 'complex_formula'
  
  // Regulatory/operational significance
  is_regulatory        boolean [default: false]       // TRUE for regulatory indicators (like X2)
  regulatory_authority text                           // 'SWRCB', 'USFWS', 'NMFS', 'DWR'
  regulatory_threshold numeric                        // Regulatory threshold value (e.g., X2 < 81 km)
  
  // Linkage to outcomes
  outcome_category_short_code text                    // FK reference to outcome_category
  
  // Source tracking
  source_ids           int[]  [not null]              // Array of source IDs (CalSim variables, reports, etc.)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (calsim_id) [unique]                              // Primary CalSim3 lookup
    (variable_type_id)                                // Find by type: system_aggregate, environmental_indicator, etc.
    (system_scope)                                    // Find by scope: statewide, delta, regional
    (hydrologic_region_id)                           // Regional queries
    (is_regulatory)                                   // Find regulatory indicators
    (is_aggregate)                                    // Find aggregate variables
    (component_variable_ids) [type: gin]             // GIN index for array operations on component variables
    (variable_id)                                     // Link to main variable system
    (source_ids) [type: gin]                          // GIN index for array operations on source IDs
    (outcome_category_short_code)                     // Outcome linkage queries
  }

  Note: '''
    System-wide, regional, and derived variables not tied to specific network nodes/arcs.
  '''
}

// Foreign key relationships for Ring 2 - Derived Variable
Ref: derived_variable.variable_type_id     > derived_variable_type.id [delete: restrict, update: cascade]
Ref: derived_variable.hydrologic_region_id > hydrologic_region.id  [delete: restrict, update: cascade]
Ref: derived_variable.unit_id              > unit.id               [delete: restrict, update: cascade]
Ref: derived_variable.temporal_scale_id    > temporal_scale.id     [delete: restrict, update: cascade]
Ref: derived_variable.variable_version_id  > version.id               [delete: restrict, update: cascade]
Ref: derived_variable.created_by           > user.id               [delete: restrict, update: cascade]
Ref: derived_variable.updated_by           > user.id               [delete: restrict, update: cascade]

//═══════════════════════════════════════════════
// RING 3: SUMMARY STATISTICS & OUTCOMES (documentation, these tables exist above from previous version TODO: rewrite schema to integrate.)
// Ring 3 and Ring 4 tables reference variables from Ring 2, which now properly link to Ring 1 topology.
//═══════════════════════════════════════════════

/*
Ring 3 tables:
- scenario_variable_statistic (links to Ring 2 variables)
- scenario_measure_statistic (links to outcome measures)
- scenario_outcome_statistic (aggregated outcomes)

Ring 4 tables:  
- theme (interpretive framework)
- tier_definition (analysis framework)
- outcome_measure (links to Ring 2 variables via measure_variable_link)
*/

//═══════════════════════════════════════════════
// RING ARCHITECTURE INTEGRATION WITH EXISTING OUTCOME SYSTEM
//═══════════════════════════════════════════════

/*
MULTI-MODEL RING-BASED ARCHITECTURE DOCUMENTATION:

RING 1: GRAPH CORE (Multi-Model Network Topology)
   - network.node: Core network nodes from multiple models (CalSim3, riparian, SoCal)
   - network.arc: Core network arcs from multiple models  
   - network.node_attributes: Extension table for variable node attributes
   - network_node_type: Node types supporting multiple models (reservoir, junction, etc.)
   - network_arc_type: Arc types supporting multiple models (inflow, channel, etc.)
   - model_source: Defines different water management models
   - Sources: CS3_NetworkSchematic_Integrated_11.28.23.xml, riparian models, SoCal water systems
   - Purpose: Unified network topology supporting multiple models with cross-model integration

RING 2: ENTITY VIEWS (Domain-Specific Rich Data)
   - reservoir_entity: Rich domain data for reservoirs (references network.node)
   - inflow_entity: Rich domain data for inflows (references network.arc)
   - channel_entity: Rich domain data for channels (references network.arc)
   - reservoir_variable, inflow_variable, channel_variable: Rich variable classifications (tied to network)
   - derived_variable: System-wide, regional, and derived variables (NOT tied to specific network elements)
   - Sources: CalSim reports, domain expertise, GIS data, operational documents
   - Purpose: Preserve domain expertise while linking to unified network topology

RING 3: SUMMARY STATISTICS (Existing - No Changes)
   - scenario_variable_statistic: Variable values per scenario
   - scenario_measure_statistic: Outcome measure values per scenario
   - Purpose: Store computational results and analysis outcomes

RING 4: INTERPRETIVE FRAMEWORK (Existing - No Changes)  
   - theme, tier_definition, outcome_measure: Analysis and interpretation framework
   - Purpose: Support dashboard views and research analysis

KEY ARCHITECTURAL BENEFITS:
- Single source of truth for network topology across all models (Ring 1)
- Support for multiple water management models in unified structure
- Cross-model analysis and comparison capabilities
- Rich domain expertise preserved (Ring 2)
- Network analysis capabilities enabled across models
- Independent versioning for topology vs domain data
- Seamless integration with existing outcome system
- Future-proof for new models (groundwater, urban systems, etc.)

MULTI-MODEL INTEGRATION EXAMPLES:

1. CALSIM3 + RIPARIAN HABITAT MODEL:
   - CalSim3 provides water flow network
   - Riparian model adds habitat nodes connected to flow network
   - Cross-model arcs link water availability to habitat quality
   - equivalent_nodes field maps CalSim reservoirs to riparian habitat zones

2. CALSIM3 + SOCAL WATER SYSTEMS:
   - CalSim3 provides statewide network
   - SoCal model provides detailed regional urban/treatment infrastructure
   - Boundary connections at key import/export points
   - parent_node_id enables hierarchical modeling (regional detail within statewide)

3. CROSS-MODEL QUERIES:
   ```sql
   -- Find all nodes from CalSim3 that connect to riparian habitat
   SELECT cs.short_code, rip.short_code, csnt.short_code as cs_node_type, ripnt.short_code as rip_node_type
   FROM network.node cs
   JOIN network_node_type csnt ON cs.node_type_id = csnt.id
   JOIN network.arc a ON cs.id = a.from_node_id
   JOIN network.node rip ON a.to_node_id = rip.id
   JOIN network_node_type ripnt ON rip.node_type_id = ripnt.id
   WHERE cs.model_source_id = (SELECT id FROM model_source WHERE short_code = 'calsim3')
   AND rip.model_source_id = (SELECT id FROM model_source WHERE short_code = 'riparian');
   
   -- Find equivalent nodes across models
   SELECT n1.short_code as calsim_node, n2.short_code as riparian_node
   FROM network.node n1
   JOIN network.node n2 ON n2.id = ANY(n1.equivalent_nodes)
   WHERE n1.model_source_id = (SELECT id FROM model_source WHERE short_code = 'calsim3')
   AND n2.model_source_id = (SELECT id FROM model_source WHERE short_code = 'riparian');
   ```

OUTCOME FLOW:

1. ENTITY TABLES → VARIABLE TABLES → OUTCOME STATISTICS

   Physical Entities                Variable Tables                  Outcome Statistics
   ─────────────────              ──────────────────               ─────────────────────
   
   reservoir_entity     ────→      reservoir_variable      ────→    scenario_variable_statistic
   │                               │                               │
   ├─ SHSTA                        ├─ S_SHSTA                      └─ Storage statistics per scenario
   ├─ OROVL                        ├─ S_SHSTA_1                    
   └─ FOLSM                        └─ S_OROVL                      
   
   inflow_entity        ────→      inflow_variable         ────→    scenario_variable_statistic
   │                               │                               │
   ├─ I_SHSTA                      ├─ I_SHSTA                      └─ Inflow statistics per scenario
   ├─ I_OROVL                      ├─ I_OROVL                      
   └─ I_FOLSM                      └─ I_FOLSM                      
   
   channel_entity       ────→      channel_variable        ────→    scenario_variable_statistic
   │                               │                               │
   ├─ SAC123                       ├─ C_SAC123 (scenario_flow)     └─ Flow statistics per scenario
   │                               ├─ C_SAC123_UNIMPAIRED (unimpaired_flow) 
   │                               └─ C_SAC123_MIF (minimum_instream_flow)  
   └─ SJR456                       
   
   [SYSTEM-WIDE]        ────→      derived_variable        ────→    scenario_variable_statistic
   │                               │                               │
   ├─ Delta conditions             ├─ NDO (net_delta_outflow)     └─ System statistics per scenario
   ├─ CVP/SWP systems              ├─ X2 (salinity_position)                      
   
2. KEY LINKING FIELDS:

   All variable tables have:
   - variable_id (uuid) → each variable has its own UUID as primary key
   - outcome_category_short_code → links to outcome_category.short_code
   
   This enables queries like:
   ```sql
   -- Find all scenario statistics for Shasta storage variables
   SELECT sv.scenario_id, rv.name, sv.statistic_type_id, sv.value
   FROM reservoir_variable rv
   JOIN scenario_variable_statistic sv ON rv.variable_id = sv.variable_id
   WHERE rv.reservoir_entity_id = (
     SELECT id FROM reservoir_entity WHERE short_code = 'SHSTA'
   );
   
   -- Compare scenario flow vs unimpaired flow for Sacramento River
   SELECT 
     chv.calsim_id,
     chv.variable_type,
     sv.statistic_type_id,
     sv.value
   FROM channel_variable chv
   JOIN scenario_variable_statistic sv ON chv.variable_id = sv.variable_id
   WHERE chv.channel_entity_id = (
     SELECT id FROM channel_entity WHERE short_code = 'SAC123'
   )
   AND chv.variable_type IN ('flow', 'unimpaired_flow')
   ORDER BY chv.variable_type, sv.statistic_type_id;
   ```

3. OUTCOME MEASURES:

   Variables can link to outcome_measure for aggregated metrics:
   - measure_variable_link connects entity-specific variable tables → outcome_measure
   - scenario_measure_statistic stores calculated outcome statistics
   
   This enables outcome-based analysis across multiple variables.
*/

//═══════════════════════════════════════════════
// NETWORK-FOCUSED THEME INTEGRATION
// Purpose: Enable themes to highlight specific network regions or critical infrastructure
//═══════════════════════════════════════════════

Table theme_network_region_link {
  theme_id            int [not null]           // FK → theme.id
  hydrologic_region_id int [not null]          // FK → hydrologic_region.id
  focus_description   text                     // "Primary network focus area for this theme"
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]

  Indexes {
    (theme_id, hydrologic_region_id) [pk]
    (hydrologic_region_id, theme_id)
  }

  Note: 'Links themes to specific network regions for research focus (e.g., "Sacramento Valley Connectivity")'
}

Ref: theme_network_region_link.theme_id            > theme.id             [delete: cascade, update: cascade]
Ref: theme_network_region_link.hydrologic_region_id > hydrologic_region.id [delete: restrict, update: cascade]
Ref: theme_network_region_link.created_by          > user.id      [delete: restrict, update: cascade]

Table theme_entity_type_focus {
  theme_id           int  [not null]           // FK → theme.id
  entity_type_id     int  [not null]           // FK → calsim_entity_type.id
  focus_description  text                      // "Primary focus on reservoir storage entities"
  focus_weight       numeric [default: 1.0]    // Relative importance weight (0.0-1.0)
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]

  Indexes {
    (theme_id, entity_type_id) [pk]
    (entity_type_id, theme_id)
  }

  Note: 'Links themes to broad entity type focus areas (e.g., all reservoir entities, all groundwater entities)'
}

Ref: theme_entity_type_focus.theme_id       > theme.id              [delete: cascade, update: cascade]
Ref: theme_entity_type_focus.entity_type_id > calsim_entity_type.id [delete: restrict, update: cascade]
Ref: theme_entity_type_focus.created_by     > user.id               [delete: restrict, update: cascade]

Table theme_focus_entity_link {
  theme_id     int  [not null]           // FK → theme.id
  node_id      int                       // FK → network.node.id (nullable)
  arc_id       int                       // FK → network.arc.id (nullable)
  significance text [not null]           // 'critical_bottleneck', 'key_junction', 'major_input', 'outcome_point'
  description  text                      // Research rationale for highlighting this specific network element
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]

  Indexes {
    (theme_id, node_id, arc_id) [pk]
    (node_id)
    (arc_id)
    (significance)
  }

  Note: 'Links themes to specific network nodes or arcs for focused analysis. CHECK ((node_id IS NOT NULL)::int + (arc_id IS NOT NULL)::int = 1) -- Exactly one of node_id or arc_id must be specified'
}

Ref: theme_focus_entity_link.theme_id > theme.id         [delete: cascade, update: cascade]
Ref: theme_focus_entity_link.node_id  > network.node.id  [delete: restrict, update: cascade]
Ref: theme_focus_entity_link.arc_id   > network.arc.id   [delete: restrict, update: cascade]
Ref: theme_focus_entity_link.created_by > user.id        [delete: restrict, update: cascade]

//────────────────────────────────────────────
// MATERIALIZED VIEWS (with read-only optimization)
//────────────────────────────────────────────

// Note: These are materialized views, not regular tables
// They will be created by the materialized_views.sql script
/*

View scenario_dashboard_summary {
  id                      int
  short_code              text
  title                   text
  subtitle                text
  description             text
  is_active               boolean
  author_name             text
  author_organization     text
  hydroclimate_code       text
  hydroclimate_name       text
  projection_year         int
  baseline_scenario_code  text
  baseline_scenario_title text
  theme_count             int     // < 100 themes
  variable_count          int     // tens of thousands per scenario
  measure_count           int     // similar to variables
  avg_variable_value      numeric
  min_variable_value      numeric
  max_variable_value      numeric
  created_at              timestamp
  updated_at              timestamp
  
  Note: 'Materialized view for scenario dashboard performance'
}

View theme_analysis_summary {
  id                      int
  short_code              text
  title                   text
  subtitle                text
  description             text
  is_active               boolean
  primary_source_code     text
  primary_source_name     text
  primary_source_citation text
  scenario_count          int     // thousands of scenarios
  active_scenario_count   int     // subset of scenarios
  outcome_category_count  int     // < 100 outcome categories
  avg_focus_weight        numeric
  assumption_count        int     // < 100 assumptions
  operation_count         int     // < 100 operations
  created_at              timestamp
  updated_at              timestamp
  
  Note: 'Materialized view for theme analysis performance'
}

View variable_statistics_summary {
  variable_id             uuid
  statistic_code          text
  statistic_name          text
  scenario_count          int     // thousands of scenarios
  active_scenario_count   int     // subset of scenarios
  avg_value               numeric
  min_value               numeric
  max_value               numeric
  stddev_value            numeric
  p25_value               numeric
  median_value            numeric
  p75_value               numeric
  p90_value               numeric
  last_updated            timestamp
  
  Note: 'Materialized view for pre-aggregated variable statistics'
}

View entity_inventory_summary {
  entity_type             text
  entity_id               int
  entity_code             text
  entity_name             text
  capacity_taf            numeric
  dead_pool_taf           numeric
  operational_purpose     text
  hydrologic_region_code  text
  hydrologic_region_name  text
  variable_count          int     // tens of thousands per entity
  scenario_count          int     // thousands of scenarios
  source_list             text[]
  created_at              timestamp
  updated_at              timestamp
  
  Note: 'Materialized view for comprehensive entity inventory'
}

View outcome_measurement_summary {
  measure_id              int
  measure_code            text
  measure_name            text
  category_code           text
  category_label          text
  unit_code               text
  unit_name               text
  temporal_scale_code     text
  spatial_scale_code      text
  theme_count             int     // < 100 themes
  theme_codes             text[]
  scenario_count          int     // thousands of scenarios
  avg_value               numeric
  min_value               numeric
  max_value               numeric
  created_at              timestamp
  updated_at              timestamp
  
  Note: 'Materialized view for outcome measurement analysis'
}
*/

//────────────────────────────────────────────
// MULTI-MODEL SUPPORT
//────────────────────────────────────────────

Table model_source {
  id           int  [pk, increment]
  short_code   text [not null, unique]           // 'calsim3', 'riparian', 'socal_water', 'groundwater'
  name         text [not null]                   // 'CalSim3', 'Riparian Habitat Model', 'SoCal Water System'
  description  text
  agency       text                              // 'DWR/USBR', 'Academic/NGO', 'MWD'
  version      text                              // 'CS3.2', 'RHM_1.0', 'SOCAL_2024'
  model_domain text                              // 'statewide', 'sacramento_valley', 'socal_region'
  is_active    boolean [not null, default: true]
  
  created_at   timestamp [default: "now()"]
  created_by   int      [not null]
  updated_at   timestamp
  updated_by   int

  Indexes {
    (short_code) [unique]
    (is_active, short_code)
    (model_domain)
  }

  Note: 'Defines different water management models that contribute nodes and arcs'
}

Ref: model_source.created_by > user.id [delete: restrict, update: cascade]
Ref: model_source.updated_by > user.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// S3 TIME SERIES ARCHITECTURE (Dual format: Snappy Parquet + Gzipped CSV)
// DESIGN: S3 stores individual variables (Parquet/Snappy) and scenario aggregations (CSV/gzip)
// INDIVIDUAL: ~10K variables × 1K scenarios = 10M Parquet+Snappy files (~10-50KB each)
// AGGREGATED: 1K scenario CSV+gzip files (~50-500MB compressed, all variables per scenario)
// DATABASE: Summary statistics only (mean, p10, p90, etc.)
//────────────────────────────────────────────
Table scenario_timeseries_file {
  id                    int       [pk, increment]
  scenario_id           int       [not null]         // FK → scenario.id
  variable_id           uuid                          // Variable identifier (NULL for scenario-level CSV files)
  
  // S3 location metadata (Parquet for individual variables, CSV for scenario aggregations)
  s3_bucket             text      [not null]         // 's3://coeqwal-timeseries'
  s3_key                text      [not null]         // 'scenario_123/variable_abc/monthly.parquet' OR 'scenario_123/all_variables.csv.gz'
  file_format           text      [not null, default: 'parquet'] // 'parquet' (individual variables) OR 'csv' (scenario-level)
  compression           text      [default: 'snappy'] // Parquet: 'snappy' (fast decompression) | CSV: 'gzip' (good ratio)
  
  // Data characteristics (100 years monthly data = 1,200 rows; variable count depends on file type)
  start_date            date      [not null]         // First timestamp in file (typically 1922-10-01)
  end_date              date      [not null]         // Last timestamp in file (typically 2022-09-30)
  record_count          int       [not null]         // Time series rows (typically 1,200 for monthly data)
  variable_count        int       [default: 1]       // Variables in file: 1 (Parquet) or ~10,000 (scenario CSV)
  temporal_resolution   text      [not null]         // 'monthly', 'daily', 'hourly' (primarily 'monthly')
  
  // File metadata (file sizes vary by type: Parquet 10-50KB, gzipped CSV 50-500MB)
  file_size_bytes       bigint                       // File size: Parquet ~10-50KB | Gzipped CSV ~50-500MB
  last_modified         timestamp [not null]         // S3 last modified timestamp
  etag                  text                         // S3 ETag for change detection
  
  // Processing metadata
  source_version_id     int       [not null]         // FK → version.id (data version)
  processing_status     text      [default: 'ready'] // 'processing', 'ready', 'error'
  processing_notes      text                         // Error messages or processing details
  
  // Quality and processing flags
  data_quality_score    numeric   [default: 1.0]     // 0.0-1.0 overall quality score
  has_quality_issues    boolean   [default: false]   // TRUE if quality checks found issues
  processing_warnings   text[]                       // Array of processing warning messages
  
  // Standard metadata
  created_at            timestamp [not null, default: "now()"]
  created_by            int       [not null]
  updated_at            timestamp [not null, default: "now()"]
  updated_by            int       [not null]

  Indexes {
    (scenario_id, variable_id) [unique]              // One file per scenario/variable (variable_id can be NULL)
    (s3_bucket, s3_key) [unique]                     // Unique S3 location
    (scenario_id)                                    // Find all files for scenario
    (variable_id)                                    // Find all scenarios for variable (excludes NULL)
    (scenario_id) [note: 'Partial index WHERE variable_id IS NULL'] // Find scenario-level CSV files
    (file_format)                                    // Find by format (parquet vs csv)
    (processing_status)                              // Find files by status
    (temporal_resolution)                            // Find files by resolution
    (last_modified)                                  // Find recently updated files
    (record_count, variable_count)                   // Find files with unexpected dimensions (QC)
    (data_quality_score)                            // Find by quality
    (has_quality_issues)                            // Find problematic files
  }

  Note: '''
    DUAL FILE ARCHITECTURE: S3 stores both individual variables (Parquet) and scenario aggregations (CSV).
    
         FILE TYPES:
     1. INDIVIDUAL VARIABLES (variable_id NOT NULL):
        - Format: Parquet with Snappy compression
        - Content: Single variable, 1,200 monthly values
        - Size: ~10-50KB per file
        - S3 key: 'scenario_123/S_SHSTA/monthly.parquet'
        
     2. SCENARIO AGGREGATIONS (variable_id IS NULL):
        - Format: CSV with gzip compression
        - Content: All variables for scenario, 1,200 rows × ~10,000 columns
        - Size: ~50-500MB compressed with gzip
        - S3 key: 'scenario_123/all_variables.csv.gz'
    
    DATABASE: Pre-computed statistics in scenario_variable_statistic (mean, p10, p90, etc.)
    
    CHECK (processing_status IN ('processing', 'ready', 'error'))
    CHECK (file_format IN ('parquet', 'csv'))
         CHECK (compression IN ('snappy', 'gzip', 'lz4', 'none'))
     CHECK ((file_format = 'parquet') = (compression = 'snappy'))  -- Parquet uses Snappy
     CHECK ((file_format = 'csv') = (compression = 'gzip'))        -- CSV uses gzip
    CHECK (temporal_resolution IN ('hourly', 'daily', 'monthly', 'annual'))
    CHECK (data_quality_score >= 0.0 AND data_quality_score <= 1.0)
    CHECK (record_count > 0 AND record_count <= 2000)  -- Time series length bounds
    CHECK (variable_count > 0 AND variable_count <= 15000)  -- Variable count bounds
    CHECK (end_date > start_date)  -- End date must be after start date
    CHECK (file_size_bytes IS NULL OR file_size_bytes > 0)  -- File size must be positive
    CHECK ((variable_id IS NULL) = (file_format = 'csv'))  -- CSV files are scenario-level only
    CHECK ((file_format = 'parquet') = (variable_count = 1))  -- Parquet files contain one variable
  '''
}

Ref: scenario_timeseries_file.scenario_id       > scenario.id [delete: restrict, update: cascade]
Ref: scenario_timeseries_file.source_version_id > version.id [delete: restrict, update: cascade]
Ref: scenario_timeseries_file.created_by        > user.id    [delete: restrict, update: cascade]
Ref: scenario_timeseries_file.updated_by        > user.id    [delete: restrict, update: cascade]

//────────────────────────────────────────────
// ETL PROCESSING METADATA (for S3 time series generation)
//────────────────────────────────────────────
Table etl_batch_run {
  id                  uuid      [pk]
  run_type            text      [not null]              // 'initial_load', 'incremental', 'reprocess', 'validation'
  scenario_batch_ids  int[]                             // Array of scenario IDs processed in this batch
  
  // Processing details
  start_time          timestamp [not null]
  end_time            timestamp
  status              text      [default: 'running']    // 'running', 'completed', 'failed', 'cancelled'
  records_processed   int       [default: 0]
  records_failed      int       [default: 0]
  error_details       text[]                           // Array of error messages
  
  // S3 output tracking
  s3_output_prefix    text                             // 's3://bucket/batch_uuid/'
  files_created       int       [default: 0]
  total_file_size_mb  numeric   [default: 0]
  
  // Processing metadata
  etl_version         text      [not null]             // ETL pipeline version
  config_used         jsonb                            // Processing configuration
  source_version_id   int       [not null]             // FK → version.id
  
  // Standard metadata
  created_at          timestamp [not null, default: "now()"]
  created_by          int       [not null]
  updated_at          timestamp [not null, default: "now()"]
  updated_by          int       [not null]

  Indexes {
    (status, start_time)                               // Find active/recent runs
    (run_type, status)                                 // Find runs by type and status
    (start_time DESC)                                  // Recent runs first
    (scenario_batch_ids) [type: gin]                   // GIN index for scenario arrays
  }

  Note: '''
    Tracks ETL batch processing runs that generate S3 time series files
    CHECK (status IN ('running', 'completed', 'failed', 'cancelled'))
    CHECK (run_type IN ('initial_load', 'incremental', 'reprocess', 'validation'))
  '''
}

Ref: etl_batch_run.source_version_id > version.id [delete: restrict, update: cascade]
Ref: etl_batch_run.created_by        > user.id    [delete: restrict, update: cascade]
Ref: etl_batch_run.updated_by        > user.id    [delete: restrict, update: cascade]

// Link S3 files to ETL batches
Table etl_file_output {
  etl_batch_id           uuid [not null]              // FK → etl_batch_run.id
  scenario_timeseries_id int  [not null]              // FK → scenario_timeseries_file.id
  processing_duration_ms int                          // Time to process this specific file
  validation_status      text [default: 'pending']    // 'pending', 'passed', 'failed'
  validation_errors      text[]                       // Array of validation errors
  
  created_at            timestamp [not null, default: "now()"]

  Indexes {
    (etl_batch_id, scenario_timeseries_id) [pk]
    (validation_status)
    (processing_duration_ms DESC)                     // Find slowest processing files
  }

  Note: '''
    Links S3 time series files to the ETL batch that created them
    CHECK (validation_status IN ('pending', 'passed', 'failed'))
  '''
}

Ref: etl_file_output.etl_batch_id           > etl_batch_run.id              [delete: cascade, update: cascade]
Ref: etl_file_output.scenario_timeseries_id > scenario_timeseries_file.id [delete: cascade, update: cascade]

//────────────────────────────────────────────
// S3 ACCESS TRACKING & OPTIMIZATION
//────────────────────────────────────────────
Table s3_access_log {
  id                    bigserial [pk, increment]
  scenario_timeseries_id int      [not null]           // FK → scenario_timeseries_file.id
  
  // Request details
  user_id               int       [not null]           // FK → user.id
  api_endpoint          text      [not null]           // '/api/scenarios/123/variables/abc/timeseries'
  request_source        text                           // 'dashboard', 'api', 'batch_download'
  
  // Access metadata
  access_timestamp      timestamp [not null, default: "now()"]
  download_size_bytes   bigint                         // Actual bytes transferred
  response_time_ms      int                            // API response time
  http_status_code      int       [not null]           // 200, 404, 500, etc.
  
  // Caching info
  cache_hit             boolean   [default: false]     // TRUE if served from cache
  cache_key             text                           // Cache identifier
  
  // Session tracking
  session_id            text                           // User session for analytics
  user_agent            text                           // Browser/client info

  Indexes {
    (scenario_timeseries_id, access_timestamp DESC)   // Recent access per file
    (user_id, access_timestamp DESC)                  // User access history
    (access_timestamp DESC)                           // Recent global access
    (cache_hit, access_timestamp)                     // Cache performance analysis
    (http_status_code, access_timestamp)              // Error analysis
  }

  Note: '''
    Tracks S3 time series file access for performance optimization and analytics
    Enables identification of frequently accessed files for caching
  '''
}

Ref: s3_access_log.scenario_timeseries_id > scenario_timeseries_file.id [delete: restrict, update: cascade]
Ref: s3_access_log.user_id                > user.id                     [delete: restrict, update: cascade]

//────────────────────────────────────────────
// S3 FILE CACHE MANAGEMENT
//────────────────────────────────────────────
Table s3_file_cache {
  id                    int       [pk, increment]
  scenario_timeseries_id int      [not null, unique]  // FK → scenario_timeseries_file.id
  
  // Cache metadata
  cache_key             text      [not null, unique]  // Redis/memcached key
  cache_size_bytes      bigint    [not null]          // Size of cached data
  cache_format          text      [not null]          // 'json', 'parquet_binary', 'csv'
  
  // Cache lifecycle
  cached_at             timestamp [not null, default: "now()"]
  last_accessed         timestamp [not null, default: "now()"]
  access_count          int       [not null, default: 0]
  expires_at            timestamp                      // NULL = no expiration
  
  // Cache strategy
  cache_strategy        text      [not null]          // 'frequent_access', 'user_requested', 'preload'
  priority_score        numeric   [default: 1.0]      // Higher = keep longer
  
  created_at           timestamp [not null, default: "now()"]
  updated_at           timestamp [not null, default: "now()"]

  Indexes {
    (cache_key) [unique]
    (last_accessed DESC)                              // LRU eviction
    (priority_score DESC, last_accessed DESC)         // Weighted LRU
    (expires_at)                                      // Expiration cleanup
    (cache_strategy)
  }

  Note: '''
    Manages caching of frequently accessed S3 time series files
    Enables intelligent cache eviction and preloading strategies
    CHECK (cache_strategy IN ('frequent_access', 'user_requested', 'preload'))
  '''
}

Ref: s3_file_cache.scenario_timeseries_id > scenario_timeseries_file.id [delete: cascade, update: cascade]

//────────────────────────────────────────────
// DATA QUALITY TRACKING FOR S3 FILES
//────────────────────────────────────────────
Table s3_data_quality_check {
  id                    int       [pk, increment]
  scenario_timeseries_id int      [not null]          // FK → scenario_timeseries_file.id
  etl_batch_id          uuid                          // FK → etl_batch_run.id (NULL for manual checks)
  
  // Quality check details
  check_type            text      [not null]          // 'completeness', 'range_validation', 'temporal_consistency', 'statistical_outliers'
  check_status          text      [not null]          // 'passed', 'warning', 'failed'
  expected_value        numeric                       // Expected result (e.g., expected record count)
  actual_value          numeric                       // Actual result
  
  // Check results
  error_count           int       [default: 0]
  warning_count         int       [default: 0]
  details               jsonb                         // Detailed check results
  error_sample          text[]                        // Sample of specific errors found
  
  // Check metadata
  checked_at            timestamp [not null, default: "now()"]
  check_duration_ms     int                           // Time taken to run check
  checker_version       text                          // Version of quality check tool
  
  created_at           timestamp [not null, default: "now()"]

  Indexes {
    (scenario_timeseries_id, check_type, checked_at DESC)  // Recent checks per file/type
    (check_status, checked_at DESC)                        // Failed checks
    (etl_batch_id)                                         // Checks per batch
  }

  Note: '''
    Tracks data quality validation results for S3 time series files
    CHECK (check_type IN ('completeness', 'range_validation', 'temporal_consistency', 'statistical_outliers'))
    CHECK (check_status IN ('passed', 'warning', 'failed'))
  '''
}

Ref: s3_data_quality_check.scenario_timeseries_id > scenario_timeseries_file.id [delete: cascade, update: cascade]
Ref: s3_data_quality_check.etl_batch_id          > etl_batch_run.id            [delete: set null, update: cascade]

//────────────────────────────────────────────
// S3 COST OPTIMIZATION & MONITORING
//────────────────────────────────────────────
Table s3_cost_tracking {
  id                    int       [pk, increment]
  scenario_timeseries_id int      [not null]          // FK → scenario_timeseries_file.id
  
  // Cost period (monthly aggregation)
  cost_month            date      [not null]          // First day of month (YYYY-MM-01)
  
  // Storage costs
  storage_class         text      [not null]          // 'standard', 'standard_ia', 'glacier', 'deep_archive'
  avg_file_size_gb      numeric   [not null]
  storage_cost_usd      numeric   [default: 0]
  
  // Transfer costs
  download_count        int       [default: 0]
  total_download_gb     numeric   [default: 0]
  transfer_cost_usd     numeric   [default: 0]
  
  // Request costs
  get_requests          int       [default: 0]
  put_requests          int       [default: 0]
  request_cost_usd      numeric   [default: 0]
  
  // Optimization recommendations
  recommended_storage_class text               // AI-generated recommendation
  potential_savings_usd     numeric [default: 0]
  last_accessed_days_ago    int               // Days since last access
  
  // Metadata
  calculated_at         timestamp [not null, default: "now()"]
  aws_billing_period    text                  // AWS billing period reference

  Indexes {
    (scenario_timeseries_id, cost_month) [unique]     // One record per file per month
    (cost_month DESC)                                 // Recent costs first
    (storage_cost_usd DESC)                           // Highest cost files
    (last_accessed_days_ago DESC)                     // Least accessed files
    (potential_savings_usd DESC)                      // Optimization opportunities
  }

  Note: '''
    Tracks S3 storage and transfer costs for optimization.
    Scale: Parquet+Snappy files (~10-50KB each) + CSV+gzip files (~50-500MB each).
    Total storage manageable. Frequent access files should stay in Standard class.
    Enables cost-based decisions for storage class transitions.
    CHECK (storage_class IN ('standard', 'standard_ia', 'glacier', 'deep_archive'))
  '''
}

Ref: s3_cost_tracking.scenario_timeseries_id > scenario_timeseries_file.id [delete: cascade, update: cascade]

//────────────────────────────────────────────
// COMPREHENSIVE TIME SERIES METADATA VIEWS
//────────────────────────────────────────────

// Materialized view for comprehensive time series metadata (for complex queries)
View timeseries_metadata_complete {
  // File identification
  file_id                    int
  s3_key                     text
  s3_bucket                  text
  file_format                text
  file_size_mb               numeric
  
  // Time series characteristics
  start_date                 date
  end_date                   date
  record_count               int
  temporal_resolution        text
  data_quality_score         numeric
  has_quality_issues         boolean
  
  // Variable metadata (complete)
  variable_id                uuid
  variable_calsim_id         text
  variable_name              text
  variable_description       text
  variable_type              text
  variable_entity_type       text
  variable_entity_name       text
  variable_unit_code         text
  variable_unit_name         text
  variable_is_regulatory     boolean
  variable_regulatory_authority text
  variable_is_aggregate      boolean
  variable_operational_purpose text
  
  // Entity context (where applicable)
  entity_id                  int
  entity_short_code          text
  entity_name                text
  entity_hydrologic_region   text
  entity_capacity_taf        numeric
  entity_operational_purpose text
  
  // Scenario metadata (complete)
  scenario_id                int
  scenario_short_code        text
  scenario_title             text
  scenario_description       text
  scenario_author_name       text
  scenario_author_org        text
  scenario_author_email      text
  scenario_is_baseline       boolean
  baseline_scenario_code     text
  baseline_scenario_title    text
  
  // Hydroclimate context
  hydroclimate_name          text
  hydroclimate_description   text
  projection_year            int
  slr_value                  numeric
  slr_unit                   text
  
  // Theme associations
  theme_codes                text[]
  theme_titles               text[]
  primary_theme_code         text
  primary_theme_title        text
  
  // Outcome linkages
  outcome_categories         text[]
  outcome_measures           text[]
  tier_classifications       text[]
  
  // Access and usage metrics
  total_downloads            int
  last_accessed              timestamp
  avg_response_time_ms       int
  cache_hit_ratio           numeric
  
  // Processing metadata
  etl_batch_id              uuid
  processing_duration_ms    int
  validation_status         text
  processing_warnings       text[]
  created_at                timestamp
  last_modified             timestamp

  Note: '''
    Comprehensive materialized view joining all time series metadata
    Updated nightly for performance - use scenario_timeseries_file for real-time queries
  '''
}

// View for API responses (JOINs to get rich metadata)
View timeseries_api_metadata {
  // File identification
  file_id                    int
  s3_key                     text
  s3_bucket                  text
  
  // Basic file info
  file_format                text
  file_size_mb               numeric
  temporal_resolution        text
  record_count               int
  start_date                 date
  end_date                   date
  
  // Variable info (from JOINs)
  variable_calsim_id         text
  variable_name              text
  variable_description       text
  variable_type              text
  variable_entity_type       text
  variable_entity_name       text
  variable_unit_code         text
  variable_unit_name         text
  
  // Scenario info (from JOINs)
  scenario_short_code        text
  scenario_title             text
  scenario_description       text
  scenario_author_name       text
  scenario_author_org        text
  hydroclimate_name          text
  baseline_scenario_code     text
  
  // Quality flags
  data_quality_score         numeric
  has_quality_issues         boolean
  processing_status          text
  processing_warnings        text[]
  
  // Metadata
  created_at                 timestamp
  last_modified              timestamp

  Note: '''
    API view with rich metadata via JOINs:
    - Joins scenario_timeseries_file with scenario, variable tables
    - Includes scenario_author, hydroclimate, unit tables
    - Can be materialized for performance if needed
  '''
}

//────────────────────────────────────────────
// S3 TIME SERIES QUERY EXAMPLES
//────────────────────────────────────────────

/*
-- Get comprehensive time series metadata for API responses
SELECT 
    stf.id,
    stf.s3_key,
    stf.s3_bucket,
    stf.file_format,
    stf.file_size_bytes / 1024 / 1024 as file_size_mb,
    stf.temporal_resolution,
    stf.record_count,
    stf.start_date,
    stf.end_date,
    
    -- Variable metadata via JOINs
    COALESCE(rv.calsim_id, cv.calsim_id, iv.calsim_id, dv.calsim_id) as variable_calsim_id,
    COALESCE(rv.name, cv.name, iv.name, dv.name) as variable_name,
    COALESCE(rv.description, cv.description, iv.description, dv.description) as variable_description,
    COALESCE(rv.variable_type, cv.variable_type, iv.variable_type, dvt.short_code) as variable_type,
    CASE 
        WHEN rv.id IS NOT NULL THEN 'reservoir'
        WHEN cv.id IS NOT NULL THEN 'channel'
        WHEN iv.id IS NOT NULL THEN 'inflow'
        WHEN dv.id IS NOT NULL THEN 'derived'
    END as variable_entity_type,
    COALESCE(re.name, ce.name, ie.name) as variable_entity_name,
    u.short_code as variable_unit_code,
    u.full_name as variable_unit_name,
    
    -- Scenario metadata via JOINs
    s.short_code as scenario_short_code,
    s.title as scenario_title,
    s.description as scenario_description,
    sa.name as scenario_author_name,
    sa.organization as scenario_author_org,
    h.name as hydroclimate_name,
    bs.short_code as baseline_scenario_code,
    
    -- Quality flags
    stf.data_quality_score,
    stf.has_quality_issues,
    stf.processing_status,
    stf.processing_warnings,
    
    -- Metadata
    stf.created_at,
    stf.last_modified
    
FROM scenario_timeseries_file stf
JOIN scenario s ON stf.scenario_id = s.id
LEFT JOIN scenario_author sa ON s.scenario_author_id = sa.id
LEFT JOIN hydroclimate h ON s.hydroclimate_id = h.id
LEFT JOIN scenario bs ON s.baseline_scenario_id = bs.id

-- Variable JOINs (exactly one will match)
LEFT JOIN reservoir_variable rv ON rv.variable_id = stf.variable_id
LEFT JOIN channel_variable cv ON cv.variable_id = stf.variable_id
LEFT JOIN inflow_variable iv ON iv.variable_id = stf.variable_id
LEFT JOIN derived_variable dv ON dv.variable_id = stf.variable_id
LEFT JOIN derived_variable_type dvt ON dv.variable_type_id = dvt.id

-- Entity JOINs (for physical entities)
LEFT JOIN reservoir_entity re ON rv.reservoir_entity_id = re.id
LEFT JOIN channel_entity ce ON cv.channel_entity_id = ce.id
LEFT JOIN inflow_entity ie ON iv.inflow_entity_id = ie.id

-- Unit JOIN
LEFT JOIN unit u ON COALESCE(rv.unit_id, cv.unit_id, iv.unit_id, dv.unit_id) = u.id

WHERE stf.processing_status = 'ready'
ORDER BY stf.created_at DESC;
*/

//────────────────────────────────────────────
// CONVENIENCE FUNCTIONS FOR TIME SERIES MANAGEMENT
//────────────────────────────────────────────

/*
-- Function to create a new time series file record (supports both Parquet and CSV files)
CREATE OR REPLACE FUNCTION create_timeseries_file(
    p_scenario_id           int,
    p_variable_id           uuid,               -- NULL for scenario-level CSV files
    p_s3_bucket             text,
    p_s3_key                text,
    p_file_format           text,               -- 'parquet' or 'csv'
    p_start_date            date,
    p_end_date              date,
    p_record_count          int,
    p_variable_count        int DEFAULT 1,      -- 1 for Parquet, ~10K for CSV
    p_temporal_resolution   text,
    p_file_size_bytes       bigint DEFAULT NULL,
    p_compression           text DEFAULT NULL,
    p_etag                  text DEFAULT NULL,
    p_created_by            int DEFAULT 1
)
RETURNS int AS $$
DECLARE
    new_file_id int;
BEGIN
    -- Insert new time series file record
    INSERT INTO scenario_timeseries_file (
        scenario_id, variable_id, s3_bucket, s3_key, file_format,
        start_date, end_date, record_count, variable_count, temporal_resolution,
        file_size_bytes, compression, etag, last_modified,
        source_version_id, created_by, updated_by
    ) VALUES (
        p_scenario_id, p_variable_id, p_s3_bucket, p_s3_key, p_file_format,
        p_start_date, p_end_date, p_record_count, p_variable_count, p_temporal_resolution,
        p_file_size_bytes, p_compression, p_etag, NOW(),
        1, p_created_by, p_created_by  -- Default to version 1
    ) RETURNING id INTO new_file_id;
    
    RETURN new_file_id;
END;
$$ LANGUAGE plpgsql;

-- Example usage for individual variable (Parquet):
-- SELECT create_timeseries_file(
--     p_scenario_id => 123,
--     p_variable_id => 'uuid-here',
--     p_s3_bucket => 'coeqwal-timeseries',
--     p_s3_key => 'scenario_123/S_SHSTA/monthly.parquet',
--     p_file_format => 'parquet',
--     p_start_date => '1921-10-31',
--     p_end_date => '2021-10-31',
--     p_record_count => 1200,
--     p_variable_count => 1,           -- Single variable
--     p_temporal_resolution => 'monthly'
-- );

-- Example usage for scenario aggregation (CSV):
-- SELECT create_timeseries_file(
--     p_scenario_id => 123,
--     p_variable_id => NULL,           -- NULL for scenario-level files
--     p_s3_bucket => 'coeqwal-timeseries',
--     p_s3_key => 'scenario_123/all_variables.csv.gz',
--     p_file_format => 'csv',
--     p_start_date => '1921-10-31',
--     p_end_date => '2021-10-31', 
--     p_record_count => 1200,
--     p_variable_count => 9847,        -- All variables for scenario
--     p_temporal_resolution => 'monthly'
-- );
*/
