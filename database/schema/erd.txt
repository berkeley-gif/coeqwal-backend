//────────────────────────────────────────────
// VERSIONING
//────────────────────────────────────────────

Table version_family {
  id          int   [pk, increment]
  short_code  text  [not null, unique]  // 'theme', 'scenario', …
  label       text
  description text
  is_active   boolean [not null, default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (is_active, short_code) }

  Note: 'Version families define domains that can be versioned independently (theme, scenario, assumption, etc.)'
}

Ref: version_family.created_by > user.id [delete: restrict, update: cascade]
Ref: version_family.updated_by > user.id [delete: restrict, update: cascade]

Table domain_family_map {
  table_name        text [pk]
  version_family_id int  [not null]
  note              text

  Note: 'Maps individual tables to their version families. Enables tooling to fetch latest active version for any domain table.'
}

Ref: domain_family_map.version_family_id > version_family.id [delete: restrict, update: cascade]

Table version {
  id                int       [pk, increment]
  version_family_id int       [not null]
  version_number    text      // semver e.g. 2.1.0; use pg_semver extension
  manifest          jsonb     // Version metadata: config, feature flags, validation rules, etc.
  changelog         text      // Human-readable change description
  is_active         boolean   [not null, default: false]
  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [default: "now()"]
  updated_by  int

  Indexes {
    (version_family_id, version_number) [unique]
    (version_family_id) [unique, note: 'Postgres partial index WHERE is_active = TRUE']
    (manifest) [type: gin, note: 'JSONB search for version metadata']
  }

  Note: '''
    Version instances for each family. Only one version per family can be active at a time.
    CHECK (version_number ~ "^[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9.]+)?$")
    CHECK (NOT (is_active = TRUE AND EXISTS (
      SELECT 1 FROM version v2 
      WHERE v2.version_family_id = version.version_family_id 
      AND v2.is_active = TRUE 
      AND v2.id != version.id
    )))
  '''
}

Ref: version.version_family_id > version_family.id [delete: restrict, update: cascade]
Ref: version.created_by > user.id [delete: restrict, update: cascade]
Ref: version.updated_by > user.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// GLOBAL LOOKUP TABLES & ENUMS
//────────────────────────────────────────────

Table user {
  id           int       [pk, increment]
  email        text      [unique]                      // Primary email address
  name         text
  display_name text      [not null]                    // Full name or service description
  affiliation  text                                    // Organization/institution
  role         text                                    // 'researcher', 'analyst', 'admin', 'service'
  
  // AWS SSO Integration (for production)
  aws_sso_user_id  text  [unique]                     // AWS SSO user ID (populated post-deployment)
  aws_sso_username text  [unique]                     // AWS SSO username (populated post-deployment)
  
  // Bootstrap vs Production user tracking
  is_bootstrap boolean   [not null, default: false]   // TRUE for CSV bootstrap users
  sync_source  text      [default: 'manual']          // 'manual', 'aws_sso', 'bootstrap'
  
  // Status and metadata
  is_active    boolean   [not null, default: true]
  last_login   timestamp
  created_at   timestamp [not null, default: "now()"]
  updated_at   timestamp [not null, default: "now()"]

  Indexes {
    (email) [unique]
    (aws_sso_user_id) [unique]
    (aws_sso_username) [unique]
    (role, is_active)
    (is_bootstrap, is_active)
    (sync_source, is_active)
  }

  Note: '''
    Hybrid user table: Bootstrap users (CSV) for initialization, AWS SSO integration for production. Bootstrap users can be deactivated after AWS SSO sync.
    CHECK (email ~ "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$")
    CHECK (role IN ("researcher", "analyst", "admin", "service", "viewer"))
  '''
}

Table source {
    id          int     [pk, increment]
    source      text    [not null, unique]   // 'calsim_report', 'james_gilbert', 'calsim_variables', 'geopackage', 'trend_report'
    description text                          // Description of the data source
    is_active   boolean [not null, default: true]

    created_at  timestamp [not null, default: "now()"]
    created_by  int      [not null]
    updated_at  timestamp [not null, default: "now()"]
    updated_by  int      [not null]

    Indexes {
        (source) [unique]
        (is_active, source)
    }

    Note: 'Unified source lookup table for all entity types'
}

Ref: source.created_by > user.id [delete: restrict, update: cascade]
Ref: source.updated_by > user.id [delete: restrict, update: cascade]

Table calsim_entity_type {
  id                  int   [pk, increment]
  type                text  [not null, unique]   // 'reservoir', 'channel', 'inflow', 'demand_unit', 'groundwater', 'delta_node'
  schematic_type_id   int                        // FK → calsim_schematic_type.id  (NULL → not on network)
  description         text 
  key_dynamic         text
  is_active           boolean [default: true]

  Indexes { (is_active, type) }
}
Ref: calsim_entity_type.schematic_type_id > calsim_schematic_type.id

Table calsim_schematic_type {
  id          int  [pk, increment]
  label  text [not null, unique]   // 'arc', 'node', null
}

//────────────────────────────────────────────
// ENTITY SYSTEM
//────────────────────────────────────────────

/*
Entity-specific tables:
- reservoir_entity, channel_entity, inflow_entity
- reservoir_variable, channel_variable, inflow_variable
*/

Table hydrologic_region {
  id         int  [pk, increment]
  short_code text [not null, unique]   // 'SAC' | 'SJR' | 'Tul' | 'SoCal'
  label      text                      // full name ("Sacramento River", …)
  is_active  boolean [not null, default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { 
    (short_code) [unique]
    (is_active, short_code)
  }
}

Ref: hydrologic_region.created_by > user.id [delete: restrict, update: cascade]
Ref: hydrologic_region.updated_by > user.id [delete: restrict, update: cascade]

Table unit {
   id              int     [pk, increment]
   short_code      text    [not null, unique] // "cfs", "taf"
   full_name       text
   canonical_group text    // "flow", "volume", "length"
   is_active       boolean [not null, default: true]

   created_at  timestamp [not null, default: "now()"]
   created_by  int      [not null]
   updated_at  timestamp [not null, default: "now()"]
   updated_by  int      [not null]

   Indexes {
     (short_code) [unique]
     (is_active, short_code)
     (canonical_group)
   }
 }

Ref: unit.created_by > user.id [delete: restrict, update: cascade]
Ref: unit.updated_by > user.id [delete: restrict, update: cascade]

 Table flow_regime {
   id          int   [pk, increment]
   short_code  text  [not null, unique] // "dry_early"
   description text
 }

 Table season {
   id          int   [pk, increment]
   label       text  [not null, unique]  // "OND", "spring"
   start_month int   // 1-12  (optional)
   end_month   int
   notes       text

   Note: '''
     CHECK (start_month BETWEEN 1 AND 12)
     CHECK (end_month BETWEEN 1 AND 12)
   '''
 }

 Table region {
   id          int   [pk, increment]
   primary_name text [not null, unique]
   type        text
   alias_names text[]
   geom        geometry(Geometry,4326)
 }

Table hydroclimate_variable_type {
  id          int  [pk, increment]
  short_code  text [not null, unique]   // 'temperature', …
  unit_id     int                      // e.g. '°C'
  unit_hint   text                      // e.g. , 'mm day-1'
  description text
  is_active   boolean [default: true]

  Indexes { (is_active, short_code) }
}

Ref: hydroclimate_variable_type.unit_id > unit.id [delete: restrict, update: cascade]

/*
Enum hydroclimate_variable_type {
  temperature
  precipitation
  evapotranspiration
  streamflow
  other
}
*/

Table variable_type {
  id          int  [pk, increment]
  short_code  text [not null, unique]   // 'output', 'control', 'decision', 'input'
  label       text [not null]           // 'Model Output', 'Control Variable', 'Decision Variable'
  description text
  is_active   boolean [default: true]

  Indexes { (is_active, short_code) }
}

/*
Enum variable_frequency_type {
  monthly
  seasonal    // e.g. "spring"
  flow_seasonal // e.g. "dry_early"
  annual
  other
}
*/

Table analysis_type {
  id          int  [pk, increment]
  short_code  text [not null, unique]   // 'cobenefit', …
  label       text
  description text
  is_active   boolean [default: true]

  Indexes { (is_active, short_code) }
}

/*
Enum analysis_type {
  cobenefit
  tradeoff
  deviation
  important
  other
}
*/

Table geometry_type {
  id          int  [pk, increment]
  short_code  text [not null, unique]
  label       text
  description text
  is_active   boolean [default: true]

  Indexes { (is_active, short_code) }
}

/*
Enum geometry_type {
  demand_unit
  wba
  hydrologic_area
  basin
  reservoir
  stream
  aquifer
  other
}
*/

Table statistic_type {
  id          int    [pk, increment]
  code        text   [not null, unique] // e.g. 'p10'
  name        text   [not null]         // e.g. '10th percentile'
  description text
  is_percentile boolean [not null, default: false]

  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (code)        [unique]
  }
}

Ref: statistic_type.created_by > user.id  [delete: restrict, update: cascade]
Ref: statistic_type.updated_by > user.id  [delete: restrict, update: cascade]

/*
INSERT INTO statistic_type (code, name, is_percentile, created_by, updated_by)
VALUES
  ('mean',   'Mean',                  FALSE, :system_user, :system_user),
  ('median', 'Median',                FALSE, :system_user, :system_user),
  ('min',    'Minimum',               FALSE, :system_user, :system_user),
  ('max',    'Maximum',               FALSE, :system_user, :system_user),
  ('p05',    '5th percentile',        TRUE,  :system_user, :system_user),
  ('p10',    '10th percentile',       TRUE,  :system_user, :system_user),
  ('p25',    '25th percentile',       TRUE,  :system_user, :system_user),
  ('p75',    '75th percentile',       TRUE,  :system_user, :system_user),
  ('p90',    '90th percentile',       TRUE,  :system_user, :system_user),
  ('p95',    '95th percentile',       TRUE,  :system_user, :system_user),
  ('other',  'Other / custom value',  FALSE, :system_user, :system_user);

-- Variable types for categorizing variables by purpose...not sure if doing this...if this is helpful. Could implement later if there is a need.
INSERT INTO variable_type (short_code, label, description, created_by, updated_by)
VALUES
  ('output', 'Model Output', 'Standard CalSim model output variables (flows, storage, etc.)', :system_user, :system_user),
  ('control', 'Control Variable', 'Operational control indicators and binary flags', :system_user, :system_user),
  ('decision', 'Decision Variable', 'Model decision variables and optimization targets', :system_user, :system_user),
  ('state', 'State Variable', 'State variables including storage zones and bookkeeping accounts', :system_user, :system_user),
  ('input', 'Input Variable', 'External inputs and boundary conditions', :system_user, :system_user),
  ('intermediate', 'Intermediate Variable', 'Calculated intermediate values used in model logic', :system_user, :system_user),
  ('aggregate', 'Aggregate Variable', 'Variables that sum or combine multiple reservoir/system components', :system_user, :system_user);
  */

//────────────────────────────────────────────
// CORE ENTITIES
//────────────────────────────────────────────

Table theme {
  id          int       [pk, increment]
  short_code  text      [not null]
  is_active   boolean   [not null, default: false]
  title       text      [not null]
  subtitle    text
  short_title text
  simple_description text
  description text
  description_next text
  narrative   jsonb
  outcome_description text
  outcome_narrative text
  source text
  theme_version_id int       [not null]
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code, is_active) [unique, note: 'UNIQUE WHERE is_active = TRUE']
    (is_active)
    (short_code) [note: 'Partial index WHERE is_active = TRUE']
  }

  Note: '''
    CHECK (short_code ~ "^[a-z0-9_]+$" AND length(short_code) BETWEEN 2 AND 50)
  '''
}

Ref: theme.theme_version_id > version.id [delete: restrict, update: cascade]
Ref: theme.created_by > user.id [delete: restrict, update: cascade]
Ref: theme.updated_by > user.id [delete: restrict, update: cascade]

Table scenario {
  id                   int      [pk, increment]
  short_code           text      [not null]
  is_active            boolean   [not null, default: false]
  title                text      [not null]
  subtitle             text
  short_title          text
  simple_description   text
  description          text
  narrative            jsonb
  baseline_scenario_id int                // NULL for baselines
  hydroclimate_id      int
  scenario_author_id            int
  scenario_version_id  int       [not null]
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code, is_active) [unique, note: 'UNIQUE WHERE is_active = TRUE']
    (is_active)
    (baseline_scenario_id)
    (hydroclimate_id)
    (is_active, scenario_version_id) [note: 'Partial index WHERE is_active = TRUE']
    (narrative) [type: gin, note: 'JSONB search']
    (title, description) [type: gin, note: 'Full-text search using to_tsvector']
  }
}

Ref: scenario.baseline_scenario_id > scenario.id [delete: set null, update: cascade]
Ref: scenario.hydroclimate_id > hydroclimate.id [delete: restrict, update: cascade]
Ref: scenario.scenario_author_id > scenario_author.id [delete: restrict, update: cascade]
Ref: scenario.scenario_version_id > version.id [delete: restrict, update: cascade]
Ref: scenario.created_by > user.id    [delete: restrict, update: cascade]
Ref: scenario.updated_by > user.id    [delete: restrict, update: cascade]

// Theme ↔ Scenario
Table theme_scenario_link {
  theme_id    int  [not null]
  scenario_id int  [not null]

  Indexes { 
    (theme_id, scenario_id) [pk]      // scenarios per theme
    (scenario_id, theme_id)           // themes per scenario
  }
}

Ref: theme_scenario_link.theme_id    > theme.id    [delete: restrict, update: cascade]
Ref: theme_scenario_link.scenario_id > scenario.id [delete: restrict, update: cascade]

Table theme_source {
  id            int   [pk, increment]
  short_code    text  [not null, unique]
  name          text  [not null]              // e.g. "May 2025 Advisory Cohort Posters"
  citation      text                         
  url           text
  doc_date      date
  notes         text

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}

Ref: theme_source.created_by > user.id [delete: restrict, update: cascade]
Ref: theme_source.updated_by > user.id [delete: restrict, update: cascade]

// Theme ↔ Theme Source
Table theme_source_link {
  theme_id   int  [not null]
  theme_source_id  int  [not null]
}

Ref: theme_source_link.theme_id > theme.id [delete: restrict, update: cascade]
Ref: theme_source_link.theme_source_id > theme_source.id [delete: restrict, update: cascade]

Table scenario_author {
  id            int   [pk, increment]
  short_code    text  [not null, unique]
  name          text  [not null]              // e.g. "James Gilbert"
  email         text
  organization  text                          // e.g. "NOAA Southwest Fisheries Science Center"
  affiliation   text                          // e.g. "COEQWAL"
  is_active     boolean [not null, default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code) [unique]
    (is_active, short_code)
  }

  Note: 'Authors of CalSim scenarios and studies'
}

Ref: scenario_author.created_by > user.id [delete: restrict, update: cascade]
Ref: scenario_author.updated_by > user.id [delete: restrict, update: cascade]

Table scenario_source {
  id            int   [pk, increment]
  short_code    text  [not null, unique]
  name          text  [not null]              // e.g. "COEQWAL_phase1_Gilbert"
  citation      text                         
  url           text
  doc_date          date
  notes         text

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code) [unique]
  }
}

Ref: scenario_source.created_by > user.id [delete: restrict, update: cascade]
Ref: scenario_source.updated_by > user.id [delete: restrict, update: cascade]

// Scenario ↔ Scenario Source
Table scenario_source_link {
  scenario_id int [not null]
  scenario_source_id   int  [not null]
}

Ref: scenario_source_link.scenario_id > scenario.id [delete: restrict, update: cascade]
Ref: scenario_source_link.scenario_source_id > scenario_source.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// ASSUMPTIONS
//────────────────────────────────────────────

Table assumption_category {
  id          int    [pk, increment]
  short_code        text   [not null, unique]  // slr, land_use, etc.
  label       text   [not null] 
  description text
  is_active   boolean   [not null, default: true]
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (is_active, short_code)
  }
}

Ref: assumption_category.created_by > user.id [delete: restrict, update: cascade]
Ref: assumption_category.updated_by > user.id [delete: restrict, update: cascade]

/*

INSERT INTO assumption_category (short_code, label)
VALUES
  ('tucp_tuco',       'TUCP/TUCO'),
  ('land_use',        'land use'),
  ('gw_restrictions', 'groundwater restrictions'),
  ('slr',             'sea level rise'),
  ('gwmodel',         'groundwater model'),
  ('other',           'other');

*/

Table assumption_definition {
  id                int   [pk, increment]
  short_code        text  [not null]
  title             text  [not null]
  category_id       int   [not null]
  description       text
  source            text
  source_access_date date
  file              text
  assumptions_version_id int [not null]
  is_active   boolean   [not null, default: true]
  notes       text
  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp
  updated_by  int

  Indexes {
    (category_id, short_code) [unique, note: 'UNIQUE WHERE is_active']
    (is_active)
  }
}

Ref: assumption_definition.category_id > assumption_category.id [delete: restrict, update: cascade]
Ref: assumption_definition.assumptions_version_id > version.id [delete: restrict, update: cascade]
Ref: assumption_definition.created_by > user.id [delete: restrict, update: cascade]
Ref: assumption_definition.updated_by > user.id [delete: restrict, update: cascade]

Table assumption_param_TUCP_TUCO {
  id              int  [pk, increment]
  assumption_id int  [not null]
  region_id   int
  season_id   int
  detail       jsonb

  Indexes { (assumption_id) }
}

Ref: assumption_param_TUCP_TUCO.assumption_id > assumption_definition.id [delete: cascade, update: restrict]
Ref: assumption_param_TUCP_TUCO.region_id > region.id [delete: restrict, update: cascade]
Ref: assumption_param_TUCP_TUCO.season_id > season.id [delete: restrict, update: cascade]

Table assumption_param_land_use {
  id              int  [pk, increment]
  assumption_id int       [not null]
  crop          text
  amount      numeric
  unit_id     int
  region_id   int
  season_id   int
  detail       jsonb
  Indexes { (assumption_id, crop) [unique] }
}

Ref: assumption_param_land_use.assumption_id > assumption_definition.id [delete: cascade, update: restrict]
Ref: assumption_param_land_use.unit_id > unit.id [delete: restrict, update: cascade]
Ref: assumption_param_land_use.season_id > season.id [delete: restrict, update: cascade]

Table assumption_param_SGMA {
  id              int  [pk, increment]
  assumption_id int       [not null]
  region_id  int
  amount    numeric
  unit_id int
  detail jsonb
  Indexes { (assumption_id, region_id) [unique] }
}

Ref: assumption_param_SGMA.assumption_id > assumption_definition.id [delete: cascade, update: restrict]
Ref: assumption_param_SGMA.region_id > region.id [delete: restrict, update: cascade]
Ref: assumption_param_SGMA.unit_id > unit.id [delete: restrict, update: cascade]

Table assumption_param_slr {
  id              int  [pk, increment]
  assumption_id  int       [not null]
  projection_year int
  slr         numeric
  unit_id     int
  detail jsonb
  Indexes { (assumption_id, slr, unit_id) [unique] }
}

Ref: assumption_param_slr.assumption_id > assumption_definition.id [delete: cascade, update: restrict]
Ref: assumption_param_slr.unit_id > unit.id [delete: restrict, update: cascade]

Table assumption_param_gwmodel {
  id              int  [pk, increment]
  assumption_id int       [not null]
  detail        jsonb
  Indexes { (assumption_id) }
}

Ref: assumption_param_gwmodel.assumption_id > assumption_definition.id [delete: cascade, update: restrict]

Table assumption_param_bioops {
  id              int  [pk, increment]
  assumption_id int       [not null]
  detail        jsonb
  Indexes { (assumption_id) }
}

Ref: assumption_param_bioops.assumption_id > assumption_definition.id [delete: cascade, update: restrict]

Table assumption_param_kv {
  id              int  [pk, increment]
  assumption_id int       [not null]
  key           text      [not null]
  value_num     numeric
  value_txt     text
  Note: 'CHECK ( (value_num IS NOT NULL)::int + (value_txt IS NOT NULL)::int = 1 )'

  unit_id       int
  region_id     int
  season_id     int
  detail       jsonb

  Indexes {
    (assumption_id, key) [unique]
  }
}

Ref: assumption_param_kv.assumption_id > assumption_definition.id [delete: cascade, update: restrict]
Ref: assumption_param_kv.unit_id > unit.id [delete: restrict, update: cascade]
Ref: assumption_param_kv.region_id > region.id [delete: restrict, update: cascade]
Ref: assumption_param_kv.season_id > season.id [delete: restrict, update: cascade]

Table theme_key_assumption_link {
  theme_id                 int  [not null]
  assumption_definition_id int  [not null]

  Indexes {
    (theme_id, assumption_definition_id) [pk]      // theme → assumptions
    (assumption_definition_id, theme_id)           // assumption → themes
  }
}

Ref: theme_key_assumption_link.theme_id                 > theme.id                 [delete: restrict, update: cascade]
Ref: theme_key_assumption_link.assumption_definition_id > assumption_definition.id [delete: restrict, update: cascade]

Table scenario_key_assumption_link {
  scenario_id   int [not null]
  assumption_id int [not null]

  Indexes {
    (scenario_id, assumption_id) [pk]   // scenario → assumptions
    (assumption_id, scenario_id)        // assumption → scenarios
  }
}

Ref: scenario_key_assumption_link.scenario_id  > scenario.id            [delete: restrict, update: cascade]
Ref: scenario_key_assumption_link.assumption_id > assumption_definition.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// OPERATIONS
//────────────────────────────────────────────

Table operation_category {
  id          int  [pk, increment]
  short_code  text [not null, unique]
  name        text
  description text
  is_active   boolean [not null, default: true]
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (is_active, short_code) }
}
  
Ref: operation_category.created_by > user.id [delete: restrict, update: cascade]
Ref: operation_category.updated_by > user.id [delete: restrict, update: cascade]

/*
INSERT INTO operation_category (short_code, label)
VALUES
  ('infrastructure',       'infrastructure'),
  ('regulatory',        'regulatory'),
  ('priority_allocation', 'priority allocation),
  ('min_flow',             'minimum flow'),
  ('gw_pumping_limit',         'groundwater pumping limit]'),
  ('ag_delivery',         'agricultural delivery]'),
  ('comm_delivery',         'community delivery]'),
  ('env_delivery',         'environmental delivery]'),
  ('delta_outflow',         'Delta outflow]'),
  ('carryover',         'reservoir carryover]'),
  ('other',           'other');
*/

Table operation_definition {
  id                   int                 [pk, increment]
  short_code           text                [not null]
  name                 text                [not null]
  category_id          int  [not null]
  description          text
  is_active          boolean   [not null, default: true]
  notes       text
  operation_version_id int    [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (is_active)
    (category_id, short_code)  [unique, note: 'UNIQUE WHERE is_active'] 
  }
}

Ref: operation_definition.operation_version_id > version.id [delete: restrict, update: cascade]
Ref: operation_definition.category_id > operation_category.id [delete: restrict, update: cascade]
Ref: operation_definition.created_by          > user.id    [delete: restrict, update: cascade]
Ref: operation_definition.updated_by          > user.id    [delete: restrict, update: cascade]

Table operation_param_priority_allocation {
  id              int    [pk, increment]
  operation_id    int    [not null]
  allocation_type text
  region_id       int
  season_id       int
  detail          jsonb

  Indexes {
    (operation_id)
  }
}

Ref: operation_param_priority_allocation.operation_id  > operation_definition.id [delete: cascade, update: restrict]
Ref: operation_param_priority_allocation.region_id > region.id [delete: restrict, update: cascade]
Ref: operation_param_priority_allocation.season_id > season.id [delete: restrict, update: cascade]

Table operation_param_minimum_flow {
  id            int    [pk, increment]
  operation_id  int    [not null]
  tributary     text
  region_id     int
  season_id     int
  flow_regime_id   int
  flow_target_value   numeric
  unit_id       int
  detail        jsonb

  Indexes {
    (operation_id) 
    (operation_id, tributary) [unique]
  }
}

Ref: operation_param_minimum_flow.operation_id  > operation_definition.id [delete: cascade, update: restrict]
Ref: operation_param_minimum_flow.region_id > region.id [delete: restrict, update: cascade]
Ref: operation_param_minimum_flow.season_id > season.id [delete: restrict, update: cascade]
Ref: operation_param_minimum_flow.flow_regime_id > flow_regime.id [delete: restrict, update: cascade]
Ref: operation_param_minimum_flow.unit_id > unit.id [delete: restrict, update: cascade]

Table operation_param_infrastructure {
  id                  int    [pk, increment]
  operation_id        int    [not null]
  infrastructure_name text
  operation_level     text
  unit_id       int
  detail          jsonb

  Indexes {
    (operation_id) 
    (operation_id, infrastructure_name) [unique]
  }
}

Ref: operation_param_infrastructure.operation_id  > operation_definition.id [delete: cascade, update: restrict]
Ref: operation_param_infrastructure.unit_id > unit.id [delete: restrict, update: cascade]

Table operation_param_regulatory {
  id             int    [pk, increment]
  operation_id   int    [not null]
  regulation_type int
  regulation_name text
  detail          jsonb

  Indexes {
    (operation_id) 
    (operation_id, regulation_type, regulation_name) [unique]
  }
}

Ref: operation_param_regulatory.operation_id  > operation_definition.id [delete: cascade, update: restrict]

Table operation_param_carryover {
  id             int    [pk, increment]
  operation_id   int    [not null]
  reservoir_id int
  amount numeric
  unit_id  int
  detail          jsonb

  Indexes {
    (operation_id) 
    (operation_id, reservoir_id, amount) [unique]
  }
}

Ref: operation_param_carryover.operation_id  > operation_definition.id [delete: cascade, update: restrict]
Ref: operation_param_carryover.reservoir_id  > reservoir_entity.id [delete: cascade, update: restrict]
Ref: operation_param_carryover.unit_id > unit.id [delete: restrict, update: cascade]

Table operation_param_kv {
  id             int    [pk, increment]
  operation_id int       [not null]
  key          text      [not null]
  value_num     numeric
  value_txt     text
  Note: 'CHECK ( (value_num IS NOT NULL)::int + (value_txt IS NOT NULL)::int = 1 )'

  unit_id       int
  region_id     int
  season_id     int
  detail       jsonb

  Indexes {
    (operation_id, key) [unique]
  }
}

Ref: operation_param_kv.operation_id  > operation_definition.id [delete: cascade, update: restrict]
Ref: operation_param_kv.unit_id > unit.id [delete: restrict, update: cascade]
Ref: operation_param_kv.region_id > region.id [delete: restrict, update: cascade]
Ref: operation_param_kv.season_id > season.id [delete: restrict, update: cascade]

Table theme_key_operation_link {
  theme_id       int [not null]
  operation_id   int [not null]

  Indexes {
    (theme_id, operation_id) [pk]
    (operation_id, theme_id)
  }
}

Ref: theme_key_operation_link.theme_id     > theme.id                [delete: restrict, update: cascade]
Ref: theme_key_operation_link.operation_id > operation_definition.id [delete: restrict, update: cascade]

Table scenario_key_operation_link {
  scenario_id  int [not null]
  operation_id int [not null]

  Indexes {
    (scenario_id, operation_id) [pk]
    (operation_id, scenario_id)
  }
}

Ref: scenario_key_operation_link.scenario_id  > scenario.id           [delete: restrict, update: cascade]
Ref: scenario_key_operation_link.operation_id > operation_definition.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// OUTCOMES
//────────────────────────────────────────────

Table outcome_category {
  id          int  [pk, increment]
  short_code  text [not null, unique]
  label       text
  description text
  outcome_version_id int  [not null]
  is_active   boolean [default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (is_active, short_code) }
}

Ref: outcome_category.outcome_version_id > version.id           [delete: restrict, update: cascade]
Ref: outcome_category.created_by         > user.id      [delete: restrict, update: cascade]
Ref: outcome_category.updated_by         > user.id      [delete: restrict, update: cascade]

Table outcome_measure {
  id                int  [pk, increment]
  outcome_category_id       int  [not null] 
  short_code        text [not null]               
  name              text [not null]
  description       text
  unit_id           int                           
  temporal_scale_id int                           
  spatial_scale_id  int                           
  calc_note         text                          
  metrics_version_id int [not null]
  is_active         boolean [default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
                               
  Indexes {
    (outcome_category_id, short_code) [unique, note: 'UNIQUE WHERE is_active = TRUE']
    (is_active)
    (outcome_category_id, short_code) [note: 'Partial index WHERE is_active = TRUE']
  }
}

Ref: outcome_measure.outcome_category_id       > outcome_category.id [delete: restrict, update: cascade]
Ref: outcome_measure.unit_id           > unit.id             [delete: restrict, update: cascade]
Ref: outcome_measure.temporal_scale_id > temporal_scale.id   [delete: restrict, update: cascade]
Ref: outcome_measure.spatial_scale_id  > spatial_scale.id    [delete: restrict, update: cascade]
Ref: outcome_measure.metrics_version_id > version.id            [delete: restrict, update: cascade]
Ref: outcome_measure.created_by        > user.id        [delete: restrict, update: cascade]
Ref: outcome_measure.updated_by        > user.id        [delete: restrict, update: cascade]

Table measure_variable_link {
  measure_id  int  [not null]
  variable_id uuid [not null]

  Indexes {
    (measure_id, variable_id) [pk]   // measure → variable
    (variable_id, measure_id)        // variable → measure
  }
}

Ref: measure_variable_link.measure_id  > outcome_measure.id  [delete: restrict, update: cascade]

//────────────────────────────────────────────
// LOOKUPS FOR OUTCOME METADATA
//────────────────────────────────────────────

Table temporal_scale {
  id          int  [pk, increment]
  short_code  text [not null, unique]   // 'monthly', 'annual', 'por', 'daily', 'seasonal'
  label       text [not null]           // 'Monthly', 'Annual', 'Period of Record'
  description text
  is_active   boolean [not null, default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code) [unique]
    (is_active, short_code)
  }
}

Ref: temporal_scale.created_by > user.id [delete: restrict, update: cascade]
Ref: temporal_scale.updated_by > user.id [delete: restrict, update: cascade]

Table spatial_scale {
  id          int  [pk, increment]
  short_code  text [not null, unique]   // 'demand_unit', 'reservoir', …
  label       text
  description text
  is_active   boolean [not null, default: true]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code) [unique]
    (is_active, short_code)
  }
}

Ref: spatial_scale.created_by > user.id [delete: restrict, update: cascade]
Ref: spatial_scale.updated_by > user.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// MAPPING CalSim VARIABLES → OUTCOMES
//────────────────────────────────────────────

Table outcome_variable_link {             
  outcome_id  int  [not null]
  variable_id uuid [not null]

  Indexes {
    (outcome_id, variable_id) [pk]        // outcome → variable(s)
    (variable_id, outcome_id)             // variable → outcome
  }
}

Ref: outcome_variable_link.outcome_id > outcome_measure.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// VALUES
//────────────────────────────────────────────

Table scenario_variable_statistic {
  scenario_id        int [not null]
  variable_id        uuid [not null]
  statistic_type_id  int  [not null]
  value              numeric [not null]
  source_version_id  int    [not null]

  created_at  timestamp [default: "now()"]
  created_by  int
  updated_at  timestamp
  updated_by  int

  Indexes {
    (scenario_id, variable_id, statistic_type_id) [pk]
    (variable_id, statistic_type_id)
    (scenario_id, variable_id)
    (variable_id, scenario_id) [note: 'Cross-scenario variable analysis']
  }

  Note: '''
    CHECK (value >= 0)
    PARTITION BY RANGE (scenario_id)
    -- Partitioned for improved query performance on large datasets
  '''
}

Ref: scenario_variable_statistic.source_version_id > version.id            [delete: restrict, update: cascade]
Ref: scenario_variable_statistic.scenario_id         > scenario.id      [delete: restrict, update: cascade]
Ref: scenario_variable_statistic.statistic_type_id         > statistic_type.id      [delete: restrict, update: cascade]
Ref: scenario_variable_statistic.created_by         > user.id      [delete: restrict, update: cascade]
Ref: scenario_variable_statistic.updated_by         > user.id      [delete: restrict, update: cascade]

Table scenario_measure_statistic {
  scenario_id        int [not null]
  measure_id         int  [not null]
  statistic_type_id  int  [not null]
  value              numeric [not null]
  source_version_id  int    [not null]

  created_at  timestamp [default: "now()"]
  created_by  int
  updated_at  timestamp
  updated_by  int

  Indexes {
    (scenario_id, measure_id, statistic_type_id) [pk]
    (measure_id, statistic_type_id) [note: 'Cross-scenario look-ups']
    (measure_id, scenario_id) [note: 'Cross-scenario measure analysis']
  }

  Note: '''
    CHECK (value >= 0)
  '''
}

Ref: scenario_measure_statistic.measure_id > outcome_measure.id [delete: restrict, update: cascade]
Ref: scenario_measure_statistic.source_version_id > version.id            [delete: restrict, update: cascade]
Ref: scenario_measure_statistic.scenario_id         > scenario.id      [delete: restrict, update: cascade]
Ref: scenario_measure_statistic.statistic_type_id         > statistic_type.id      [delete: restrict, update: cascade]
Ref: scenario_measure_statistic.created_by         > user.id      [delete: restrict, update: cascade]
Ref: scenario_measure_statistic.updated_by         > user.id      [delete: restrict, update: cascade]

Table scenario_outcome_statistic {
  scenario_id      int [not null]
  outcome_id       int  [not null]
  statistic_type_id int  [not null]
  value            numeric [not null]

  source_version_id int [not null]
  created_at  timestamp [default: "now()"]
  created_by  int
  updated_at  timestamp
  updated_by  int

  Indexes {
    (scenario_id, outcome_id, statistic_type_id) [pk]
    (outcome_id, statistic_type_id)
  }
}

Ref: scenario_outcome_statistic.source_version_id > version.id            [delete: restrict, update: cascade]
Ref: scenario_outcome_statistic.scenario_id         > scenario.id      [delete: restrict, update: cascade]
Ref: scenario_outcome_statistic.outcome_id         > outcome_measure.id      [delete: restrict, update: cascade]
Ref: scenario_outcome_statistic.statistic_type_id         > statistic_type.id      [delete: restrict, update: cascade]
Ref: scenario_outcome_statistic.created_by         > user.id      [delete: restrict, update: cascade]
Ref: scenario_outcome_statistic.updated_by         > user.id      [delete: restrict, update: cascade]

Table scenario_category_statistic {
  scenario_id      int [not null, ref: > scenario.id]
  category_id      int  [not null, ref: > outcome_category.id]
  statistic_type_id int  [not null, ref: > statistic_type.id]
  value            numeric [not null]
  source_version_id int [not null, ref: > version.id]
  created_at  timestamp [default: "now()"]
  created_by  int
  updated_at  timestamp
  updated_by  int

  Indexes {
    (scenario_id, category_id, statistic_type_id) [pk]
    (category_id, statistic_type_id)
  }
}

//═══════════════════════════════════════════════
// THEME-OUTCOME INTEGRATION
//═══════════════════════════════════════════════

Table theme_outcome_priority {
  theme_id            int     [not null]              // FK → theme.id
  outcome_category_id int     [not null]              // FK → outcome_category.id  
  priority_rank       int     [not null]              // 1 = highest priority for this theme
  focus_weight        numeric [default: 1.0]          // Relative importance weight (0.0-1.0)
  research_rationale  text                            // Why this outcome is key for this theme
  measurement_focus   text                            // Specific measurement emphasis for theme
  
  created_at          timestamp [not null, default: "now()"]
  created_by          int      [not null]
  updated_at          timestamp
  updated_by          int

  Indexes {
    (theme_id, priority_rank) [unique]                // Each rank unique within theme
    (theme_id, outcome_category_id) [unique]          // Each outcome unique within theme
    (outcome_category_id, theme_id)                   // Reverse lookup
    (priority_rank)                                   // Cross-theme priority analysis
  }

  Note: '''
    Links themes to prioritized outcome categories with research focus details
    CHECK (focus_weight >= 0.0 AND focus_weight <= 1.0)
  '''
}

Ref: theme_outcome_priority.theme_id            > theme.id            [delete: cascade, update: cascade]
Ref: theme_outcome_priority.outcome_category_id > outcome_category.id [delete: restrict, update: cascade]
Ref: theme_outcome_priority.created_by          > user.id      [delete: restrict, update: cascade]
Ref: theme_outcome_priority.updated_by          > user.id      [delete: restrict, update: cascade]

Table theme_outcome_measure_focus {
  theme_id         int     [not null]              // FK → theme.id
  outcome_measure_id int   [not null]              // FK → outcome_measure.id
  focus_level      text    [not null]              // 'primary', 'secondary', 'contextual'
  analytical_emphasis text                         // Specific analytical focus for this theme
  tier_relevance   boolean [default: false]       // TRUE if tier classification is key for theme
  
  created_at       timestamp [not null, default: "now()"]
  created_by       int      [not null]

  Indexes {
    (theme_id, outcome_measure_id) [pk]
    (outcome_measure_id, theme_id)
    (focus_level)
    (tier_relevance)
  }

  Note: 'Links themes to specific outcome measures with analytical focus details'
}

Ref: theme_outcome_measure_focus.theme_id           > theme.id         [delete: cascade, update: cascade]
Ref: theme_outcome_measure_focus.outcome_measure_id > outcome_measure.id [delete: restrict, update: cascade]
Ref: theme_outcome_measure_focus.created_by         > user.id    [delete: restrict, update: cascade]

//────────────────────────────────────────────
// HYDROCLIMATE
//────────────────────────────────────────────

Table hydroclimate_source {
  id                      int       [pk, increment]
  short_code              text      [not null, unique]
  name                    text
  description             text
  citation                text
  url                     text
  notes                   text
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (short_code) }
}

Ref: hydroclimate_source.created_by          > user.id    [delete: restrict, update: cascade]
Ref: hydroclimate_source.updated_by          > user.id    [delete: restrict, update: cascade]

Table hydroclimate {
  id                      int       [pk, increment]
  short_code              text      [not null, unique]
  name                    text
  description             text
  is_active               boolean [not null, default: true]
  projection_year         int
  slr_value               numeric
  slr_unit_id             int
  source_id               int                       // FK → hydroclimate_source.id
  notes                   text
  hydroclimate_version_id int
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (is_active, short_code) (source_id) }
}

Ref: hydroclimate.hydroclimate_version_id > version.id            [delete: restrict, update: cascade]
Ref: hydroclimate.source_id              > hydroclimate_source.id [delete: restrict, update: cascade]
Ref: hydroclimate.slr_unit_id            > unit.id              [delete: restrict, update: cascade]
Ref: hydroclimate.created_by             > user.id            [delete: restrict, update: cascade]
Ref: hydroclimate.updated_by             > user.id            [delete: restrict, update: cascade]

Table hydroclimate_variable_summary {
  id                  int       [pk, increment]
  hydroclimate_id     int       [not null]
  variable_type_id    int [not null]
  unit_id             int
  description         text
  distribution_data   jsonb   
  variable_version_id int       [not null]
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (hydroclimate_id, variable_type_id) [unique]
  }
}

Ref: hydroclimate_variable_summary.variable_type_id > hydroclimate_variable_type.id [delete: restrict, update: cascade]
Ref: hydroclimate_variable_summary.hydroclimate_id > hydroclimate.id [delete: cascade, update: restrict]
Ref: hydroclimate_variable_summary.unit_id         > unit.id      [delete: restrict, update: cascade]
Ref: hydroclimate_variable_summary.variable_version_id > version.id   [delete: restrict, update: cascade]
Ref: hydroclimate_variable_summary.created_by             > user.id            [delete: restrict, update: cascade]
Ref: hydroclimate_variable_summary.updated_by             > user.id            [delete: restrict, update: cascade]

//────────────────────────────────────────────
// CALSIM VARIABLES
//────────────────────────────────────────────

// REMOVED: calsim_variable table - using entity-specific variable tables instead
// (reservoir_variable, channel_variable, inflow_variable)

//────────────────────────────────────────────
// VARIABLE GROUPING SYSTEM
//────────────────────────────────────────────

// Define types of variable groups
Table variable_group_type {
  id          int    [pk, increment]
  short_code  text   [not null, unique]   // 'tier_storage', 'reporting', 'analysis', 'dashboard'
  name        text   [not null]           // 'Tier Storage Variables', 'Reporting Variables'
  description text
  is_active   boolean [not null, default: true]
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (short_code) [unique]
    (is_active, short_code)
  }
}

Ref: variable_group_type.created_by > user.id [delete: restrict, update: cascade]
Ref: variable_group_type.updated_by > user.id [delete: restrict, update: cascade]

// Define specific variable groups
Table variable_group {
  id                   int     [pk, increment]
  group_type_id        int     [not null]           // FK → variable_group_type.id
  short_code           text    [not null]           // 'tier_storage_reservoirs', 'dashboard_storage'
  name                 text    [not null]           // 'Tier Storage Reservoirs', 'Dashboard Storage Variables'
  description          text
  purpose              text                         // 'Used for tier classification of reservoir storage'
  selection_criteria   text                         // 'Major storage reservoirs with capacity > 100 TAF'
  is_active            boolean [not null, default: true]
  variable_version_id  int     [not null]           // FK → version.id (for versioning group definitions)
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (group_type_id, short_code) [unique]
    (is_active, group_type_id)
  }
}

Ref: variable_group.group_type_id       > variable_group_type.id [delete: restrict, update: cascade]
Ref: variable_group.variable_version_id > version.id                [delete: restrict, update: cascade]
Ref: variable_group.created_by          > user.id           [delete: restrict, update: cascade]
Ref: variable_group.updated_by          > user.id           [delete: restrict, update: cascade]

//────────────────────────────────────────────
// SCENARIO OUTCOMES & TIERS
//────────────────────────────────────────────
Table outcome_definition {
  id                 int   [pk, increment]
  name               text  [unique, not null]
  description        text
  units              text
  method             text
  source             text
  metrics_version_id int   [not null]
  created_at         timestamp [default: "now()"]
  updated_at         timestamp
}

Ref: outcome_definition.metrics_version_id > version.id [delete: restrict, update: cascade]

Table tier_definition {
  id              int  [pk, increment]
  name            text [not null, unique]
  description     text
  rationale       text
  method          text
  outcome_measures text[]
  is_active       boolean   [not null, default: false]
  tier_version_id int       [not null]
  created_at      timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at      timestamp [default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (is_active, name)
  }
}

Ref: tier_definition.tier_version_id > version.id [delete: restrict, update: cascade]
Ref: tier_definition.created_by  > user.id   [delete: restrict, update: cascade]
Ref: tier_definition.updated_by  > user.id   [delete: restrict, update: cascade]

Table tier_level {
  tier_id             int  [not null]
  level               int  [not null]

  label               text
  short_description   text
  detailed_description text
  tier_version_id     int  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (tier_id, level) [pk] }
}
Ref: tier_level.tier_id        > tier_definition.id         [delete: cascade,  update: cascade]
Ref: tier_level.tier_version_id> version.id      [delete: restrict, update: cascade]
Ref: tier_level.created_by     > user.id [delete: restrict, update: cascade]
Ref: tier_level.updated_by     > user.id [delete: restrict, update: cascade]

Table tier_outcome_link {
  tier_id    int [not null]
  outcome_id int [not null]

  Indexes {
    (tier_id, outcome_id) [pk]
    (outcome_id, tier_id)
  }
}

Ref: tier_outcome_link.tier_id    > tier_definition.id            [delete: restrict, update: cascade]
Ref: tier_outcome_link.outcome_id > outcome_definition.id [delete: restrict, update: cascade]

// Link variable groups to tier definitions
Table tier_variable_group_link {
  tier_id  int [not null]           // FK → tier_definition.id
  group_id int [not null]           // FK → variable_group.id
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]

  Indexes {
    (tier_id, group_id) [pk]
    (group_id, tier_id)
  }
}

Ref: tier_variable_group_link.tier_id    > tier_definition.id [delete: cascade, update: cascade]
Ref: tier_variable_group_link.group_id   > variable_group.id  [delete: cascade, update: cascade]
Ref: tier_variable_group_link.created_by > user.id    [delete: restrict, update: cascade]

//────────────────────────────────────────────
// METADATA SUBTABLES
//────────────────────────────────────────────
Table scenario_metadata {
  id              uuid   [pk]
  scenario_id     int   [not null]
  theme_id        int    [not null]

  study_name      text
  alias           text
  version         text
  url             text
  created         date
  last_modified   date
  raw             jsonb  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { 
    (scenario_id) [unique]
    (study_name) 
    (alias)
    (theme_id, scenario_id) 
  }
}
Ref: scenario_metadata.theme_id    > theme.id      [delete: restrict, update: cascade]
Ref: scenario_metadata.scenario_id > scenario.id   [delete: cascade,  update: restrict]
Ref: scenario_metadata.created_by  > user.id [delete: restrict, update: cascade]
Ref: scenario_metadata.updated_by  > user.id [delete: restrict, update: cascade]

Table scenario_ancillary_output {
  id                   uuid [pk]
  scenario_metadata_id uuid [not null]
  output_type          text
  file_name            text
  metadata_version_id  int  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: scenario_ancillary_output.scenario_metadata_id > scenario_metadata.id [delete: restrict, update: cascade]
Ref: scenario_ancillary_output.metadata_version_id  > version.id           [delete: restrict, update: cascade]
Ref: scenario_ancillary_output.created_by           > user.id     [delete: restrict, update: cascade]
Ref: scenario_ancillary_output.updated_by           > user.id     [delete: restrict, update: cascade]

//────────────────────────────────────────────
//  EXTERNAL MODEL METADATA
//────────────────────────────────────────────
Table model_source {
  id                int   [pk, increment]
  name              text  [unique, not null]
  version_family_id int   [not null]
  description       text
  contact           text
  notes             text

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: model_source.version_family_id > version_family.id [delete: restrict, update: cascade]
Ref: model_source.created_by        > user.id   [delete: restrict, update: cascade]
Ref: model_source.updated_by        > user.id   [delete: restrict, update: cascade]

Table model_variable {
  id                  int   [pk, increment]
  model_source_id     int   [not null]              
  short_code          text  [not null]
  name                text
  unit_id             int
  temporal_scale_id   int   [not null]              // FK → temporal_scale.id (data generation frequency)
  geometry_type_id    int
  description         text
  variable_version_id int   [not null]              

  Indexes { (model_source_id, short_code) [unique] }
}

Ref: model_variable.model_source_id     > model_source.id [delete: restrict, update: cascade]
Ref: model_variable.variable_version_id > version.id      [delete: restrict, update: cascade]
Ref: model_variable.unit_id > unit.id [delete: restrict, update: cascade]
Ref: model_variable.temporal_scale_id > temporal_scale.id [delete: restrict, update: cascade]
Ref: model_variable.geometry_type_id > geometry_type.id [delete: restrict, update: cascade]

Table model_run {
  id              uuid [pk]
  model_source_id int  [not null]
  scenario_id     int [not null]
  run_timestamp   timestamp [not null]
  manifest        jsonb
  notes           text

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (model_source_id, scenario_id, run_timestamp) [unique] }
}
Ref: model_run.model_source_id > model_source.id [delete: restrict, update: cascade]
Ref: model_run.scenario_id     > scenario.id     [delete: restrict, update: cascade]
Ref: model_run.created_by      > user.id [delete: restrict, update: cascade]
Ref: model_run.updated_by      > user.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
//  EXTERNAL MODEL – SCALAR VALUES
//────────────────────────────────────────────

Table model_value {
  id                int     [pk, increment]
  model_run_id      uuid    [not null]
  variable_id       int     [not null]
  geometry_id       uuid
  value             numeric [not null]
  source_version_id int     [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes {
    (model_run_id, variable_id, geometry_id) [unique]
    (variable_id, geometry_id)
    (geometry_id)
  }
}
Ref: model_value.model_run_id      > model_run.id      [delete: cascade,  update: cascade]
Ref: model_value.variable_id       > model_variable.id [delete: restrict, update: cascade]
Ref: model_value.geometry_id       > geometry.id       [delete: set null, update: cascade]
Ref: model_value.source_version_id > version.id        [delete: restrict, update: cascade]
Ref: model_value.created_by        > user.id   [delete: restrict, update: cascade]
Ref: model_value.updated_by        > user.id   [delete: restrict, update: cascade]

//────────────────────────────────────────────
// INTERPRETIVE FRAMEWORK
//────────────────────────────────────────────

Table analysis {
  id                     int  [pk, increment]
  name                   text [unique, not null]
  description            text
  analysis_type_id       int
  notes                  text
  interpretive_version_id int [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: analysis.analysis_type_id       > analysis_type.id [delete: restrict, update: cascade]
Ref: analysis.interpretive_version_id> version.id          [delete: restrict, update: cascade]
Ref: analysis.created_by             > user.id     [delete: restrict, update: cascade]
Ref: analysis.updated_by             > user.id     [delete: restrict, update: cascade]

Table key_concept {
  id                     int  [pk, increment]
  name                   text [unique, not null]
  definition             text
  interpretive_version_id int  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: key_concept.interpretive_version_id > version.id      [delete: restrict, update: cascade]
Ref: key_concept.created_by              > user.id [delete: restrict, update: cascade]
Ref: key_concept.updated_by              > user.id [delete: restrict, update: cascade]

Table chart_type {
  id                     int  [pk, increment]
  type                   text [unique, not null]
  interpretive_version_id int  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: chart_type.interpretive_version_id > version.id      [delete: restrict, update: cascade]
Ref: chart_type.created_by              > user.id [delete: restrict, update: cascade]
Ref: chart_type.updated_by              > user.id [delete: restrict, update: cascade]

Table ancillary_data {
  id                       int  [pk, increment]
  name                     text [unique, not null]
  data                     json
  description              text
  source                   text
  interpretive_version_id  int  [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]
}
Ref: ancillary_data.interpretive_version_id > version.id      [delete: restrict, update: cascade]
Ref: ancillary_data.created_by              > user.id [delete: restrict, update: cascade]
Ref: ancillary_data.updated_by              > user.id [delete: restrict, update: cascade]

Table theme_key_concept_link {
  theme_id       int [not null]
  key_concept_id int [not null]

  Indexes {
    (theme_id, key_concept_id) [pk]
    (key_concept_id, theme_id)
  }
}

Ref: theme_key_concept_link.theme_id       > theme.id       [delete: restrict, update: cascade]
Ref: theme_key_concept_link.key_concept_id > key_concept.id [delete: restrict, update: cascade]

Table theme_chart_type_link {
  theme_id     int [not null]
  chart_type_id int [not null]

  Indexes {
    (theme_id, chart_type_id) [pk]
    (chart_type_id, theme_id)
  }
}

Ref: theme_chart_type_link.theme_id     > theme.id     [delete: restrict, update: cascade]
Ref: theme_chart_type_link.chart_type_id > chart_type.id [delete: restrict, update: cascade]

Table theme_ancillary_data_link {
  theme_id          int [not null]
  ancillary_data_id int [not null]

  Indexes {
    (theme_id, ancillary_data_id) [pk]
    (ancillary_data_id, theme_id)
  }
}

Ref: theme_ancillary_data_link.theme_id          > theme.id          [delete: restrict, update: cascade]
Ref: theme_ancillary_data_link.ancillary_data_id > ancillary_data.id [delete: restrict, update: cascade]

Table theme_analysis_link {
  theme_id    int [not null]
  analysis_id int [not null]

  Indexes {
    (theme_id, analysis_id) [pk]
    (analysis_id, theme_id)
  }
}

Ref: theme_analysis_link.theme_id    > theme.id    [delete: restrict, update: cascade]
Ref: theme_analysis_link.analysis_id > analysis.id [delete: restrict, update: cascade]

// Link themes to variable groups (what variables are key for each theme)
Table theme_variable_group_link {
  theme_id int [not null]           // FK → theme.id
  group_id int [not null]           // FK → variable_group.id
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]

  Indexes {
    (theme_id, group_id) [pk]
    (group_id, theme_id)
  }
}

Ref: theme_variable_group_link.theme_id    > theme.id         [delete: cascade, update: cascade]
Ref: theme_variable_group_link.group_id    > variable_group.id [delete: cascade, update: cascade]
Ref: theme_variable_group_link.created_by  > user.id  [delete: restrict, update: cascade]

//────────────────────────────────────────────
// GEOMETRY & CONSTANTS
//────────────────────────────────────────────
Table geometry {
  id                 uuid   [pk]
  name               text
  geometry_type_id   int    [not null]        // FK → geometry_type.id
  geom               geometry(Geometry,4326)
  geometries_version_id int [not null]

  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp [not null, default: "now()"]
  updated_by  int      [not null]

  Indexes { (geom) [type: gist] }
}

Ref: geometry.geometry_type_id       > geometry_type.id [delete: restrict, update: cascade]
Ref: geometry.geometries_version_id  > version.id          [delete: restrict, update: cascade]
Ref: geometry.created_by             > user.id     [delete: restrict, update: cascade]
Ref: geometry.updated_by             > user.id     [delete: restrict, update: cascade]

Table geometry_lookup {
  id            uuid   [pk]
  geometry_id   uuid   [not null]
  variable_id   uuid   [not null]
  attribute_name text
  value         numeric

  Indexes {
    (geometry_id)
    (variable_id)
  }
}

Ref: geometry_lookup.geometry_id > geometry.id [delete: cascade, update: cascade]

Table node {
  id              uuid [pk]
  name            text
  geometry_type_id int  // null-able
  geom            geometry(Point,4326) [not null]

  Indexes { (geom) [type: gist] }
}

Ref: node.geometry_type_id > geometry_type.id [delete: restrict, update: cascade]

Table arc {
  id              uuid [pk]
  from_node_id    uuid [not null, ref: > node.id]
  to_node_id      uuid [not null, ref: > node.id]
  geometry_type_id int  // optional
  geom            geometry(LineString,4326) [not null]
  metadata        json

  Indexes {
    (from_node_id)
    (to_node_id)
    (geom) [type: gist]
  }
}

Ref: arc.geometry_type_id > geometry_type.id [delete: restrict, update: cascade]

Table geometry_attributes_node {
  id                  uuid   [pk]
  geometry_id         uuid   [not null]
  sub_type            text
  region_id           int
  shape_length        numeric
  Indexes { (geometry_id) [unique] }
}

Ref: geometry_attributes_node.geometry_id > geometry.id [delete: cascade, update: restrict]
Ref: geometry_attributes_node.region_id > region.id [delete: restrict, update: cascade]

Table geometry_attributes_arc {
  id                 uuid   [pk]
  geometry_id        uuid   [not null]
  arc_description    text
  from_node          text
  to_node            text
  shape_length       numeric
  Indexes { (geometry_id) [unique] }
}

Ref: geometry_attributes_arc.geometry_id > geometry.id [delete: cascade, update: restrict]

Table geometry_attributes_demand_unit {
  id           uuid   [pk]
  geometry_id  uuid   [not null]
  crop_type    text
  region_id    int
  area_ha      numeric
  Indexes { (geometry_id) [unique] }
}

Ref: geometry_attributes_demand_unit.geometry_id > geometry.id [delete: cascade, update: restrict]
Ref: geometry_attributes_demand_unit.region_id > region.id [delete: restrict, update: cascade]

Table constant {
  id                   uuid   [pk]
  label                text
  year                 int
  value                text
  source               text
  metadata_version_id  int    [not null]
  Indexes { (label, year) [unique] }
}

Ref: constant.metadata_version_id > version.id [delete: restrict, update: cascade]

//────────────────────────────────────────────
// CALSIM VARIABLE TIMESERIES (RAW OUTPUT)
//────────────────────────────────────────────
Table scenario_variable_timeseries {
  scenario_id int      [not null, ref: > scenario.id]
  variable_id uuid      [not null] 
  timestamp   timestamp [not null]
  value       numeric   [not null]
  created_at  timestamp [not null, default: "now()"]

  Indexes {
    (scenario_id, variable_id, timestamp) [unique]
  }
}

//────────────────────────────────────────────
// SCENARIO OUTCOME RESULTS (AGGREGATES)
//────────────────────────────────────────────
Table scenario_outcome_value {
  scenario_id int  [not null, ref: > scenario.id]
  outcome_id  int   [not null, ref: > outcome_definition.id]
  geometry_id uuid  [ref: > geometry.id]
  time_period      text                        
  stat        statistic_type [not null]
  value       numeric      [not null]
  created_at  timestamp    [default: "now()"]

  Indexes {
    (scenario_id, outcome_id, geometry_id, time_period, stat) [unique]
  }
}

Table scenario_tier_value {
  scenario_id   int  [ref: > scenario.id]
  outcome_id    int   [ref: > outcome_definition.id, note: 'NULL → row is for variable']
  variable_id   uuid  [note: 'NULL → row is for outcome']
  tier_id       int   [not null, ref: > tier_definition.id]
  level         int   [not null, note: '1-4']
  geometry_id   uuid  [ref: > geometry.id]
  time_period   text  [not null]

  source_version_id int  [not null, ref: > version.id]
  created_by  int [not null, ref: > user.id]
  created_at        timestamp [default: "now()"]
  updated_at        timestamp

  Note: 'CHECK ( (outcome_id IS NOT NULL)::int + (variable_id IS NOT NULL)::int = 1 )'

  Indexes {
    // Composite "business key" (acts as PK in dbdiagram)
    (scenario_id, outcome_id, variable_id, tier_id, geometry_id, time_period) [pk]

    // Helper indexes (had to write the WHERE in a note so DBML parses)
    (scenario_id, outcome_id)  [note: 'Postgres partial index WHERE outcome_id IS NOT NULL']
    (scenario_id, variable_id) [note: 'Postgres partial index WHERE variable_id IS NOT NULL']
  }
}

//────────────────────────────────────────────
//  CO‑BENEFITS / TRADE‑OFFS / LARGE DELTAS
//────────────────────────────────────────────

Table scenario_outcome_delta {
  id                     int   [pk, increment]

  scenario_id            int  [not null, ref: > scenario.id]
  baseline_scenario_id   int  [not null, ref: > scenario.id]
  outcome_id             int   [not null, ref: > outcome_definition.id]

  stat                   text         
  value                  numeric     

  analysis_type_id       int
  rationale              text        
  significance_flag      boolean       // TRUE = flagged as "key" in dashboards

  created_at             timestamp [default: "now()"]

  Indexes {
    (scenario_id, outcome_id, stat) [unique]   
    (analysis_type_id)
  }
}

Ref: scenario_outcome_delta.analysis_type_id > analysis_type.id [delete: restrict, update: cascade]

Table analysis_result_delta {
  analysis_id int [not null]
  delta_id    int [not null]

  Indexes { (analysis_id, delta_id) [pk] }
}

Ref: analysis_result_delta.analysis_id > analysis.id [delete: cascade, update: cascade]
Ref: analysis_result_delta.delta_id > scenario_outcome_delta.id [delete: cascade, update: cascade]



//────────────────────────────────────────────
// RING-BASED CALSIM ARCHITECTURE!
//────────────────────────────────────────────

//═══════════════════════════════════════════════
// RING 1: GRAPH CORE (Network Topology)
// Single Source: CS3_NetworkSchematic_Integrated_11.28.23.xml
//═══════════════════════════════════════════════

// Arc type lookup table for consistency
Table network_arc_type {
  id          int  [pk, increment]
  short_code  text [not null, unique]           // 'inflow', 'channel', 'diversion', 'bypass', 'return_flow'
  name        text [not null]                   // 'Inflow Arc', 'Channel Arc', 'Diversion Arc'
  description text
  is_active   boolean [not null, default: true]
  
  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp
  updated_by  int

  Indexes {
    (short_code) [unique]
    (is_active, short_code)
  }

  Note: 'Lookup table for network arc types to maintain consistency and prevent typos'
}

Ref: network_arc_type.created_by > user.id [delete: restrict, update: cascade]
Ref: network_arc_type.updated_by > user.id [delete: restrict, update: cascade]

// SCHEMA: network
// Core network topology tables organized under network schema
Table network.node {
  id                   int    [pk, increment]
  short_code           text   [not null]              // 'SHSTA', 'FOLSM', 'SAC001', 'JUNCTION_42'
  node_type            text   [not null]              // 'reservoir', 'junction', 'diversion', 'demand_unit', 'outflow'
  name                 text                           // Human-readable name from XML
  description          text                           // Description from XML or domain knowledge
  diagram_id           int    [not null]              // Source-agnostic reference to diagram node ID
  
  // Minimal network-only attributes
  geom                 geometry(Point,4326)           // Spatial location if available
  
  // Versioning and source tracking
  network_version_id   int    [not null]              // FK → version.id (network topology version)
  source_ids           int[]  [not null]              // Array of source IDs - should be [network_schematic_source_id]
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (network_version_id, short_code) [unique]          // Composite unique constraint - no duplicate names per version
    (diagram_id) [unique]                              // Authoritative diagram reference
    (node_type)                                        // Find nodes by type
    (network_version_id)                               // Version-specific queries
    (source_ids) [type: gin]                           // GIN index for array operations on sources
    (geom) [type: gist]                                // GIST index for spatial queries
  }

  Note: 'Core network nodes from CalSim XML schematic. Represents points in the network topology.'
}

Table network.arc {
  id                   int    [pk, increment]
  short_code           text   [not null]              // 'I_SHSTA', 'C_SAC123', 'D_SHSTA_PU1'
  arc_type_id          int    [not null]              // FK → network_arc_type.id
  name                 text                           // Human-readable name from XML
  description          text                           // Description from XML or domain knowledge
  diagram_id           int    [not null]              // Source-agnostic reference to diagram link ID
  
  // Network topology - THE definitive connections
  from_node_id         int                            // FK → network.node.id (nullable for boundary inflows)
  to_node_id           int    [not null]              // FK → network.node.id (all arcs must terminate)
  
  // Directional flow properties
  is_reversible        boolean [not null, default: false] // TRUE if flow can go both directions
  
  // Minimal network-only attributes
  geom                 geometry(LineString,4326)      // Spatial path if available
  
  // Versioning and source tracking
  network_version_id   int    [not null]              // FK → version.id (network topology version)
  source_ids           int[]  [not null]              // Array of source IDs - should be [network_schematic_source_id]
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (network_version_id, short_code) [unique]          // Composite unique constraint - no duplicate names per version
    (diagram_id) [unique]                              // Authoritative diagram reference
    (arc_type_id)                                      // Find arcs by type
    (from_node_id)                                     // B-tree index for one-hop traversals (outgoing arcs)
    (to_node_id)                                       // B-tree index for one-hop traversals (incoming arcs)
    (network_version_id)                               // Version-specific queries
    (source_ids) [type: gin]                           // GIN index for array operations on sources
    (geom) [type: gist]                                // GIST index for spatial queries
    (is_reversible)                                    // Find reversible arcs
  }

  Note: 'Core network arcs from CalSim XML schematic. Represents connections in the network topology.'
}

// Extension table for variable node attributes (key-value pattern)
Table network.node_attributes {
  id          int  [pk, increment]
  node_id     int  [not null]                         // FK → network.node.id
  attr_key    text [not null]                         // 'outlet_type', 'flow_split_ratio', 'demand_priority'
  attr_value  text [not null]                         // Attribute value as text
  data_type   text [not null, default: 'text']        // 'text', 'numeric', 'boolean', 'json'
  
  // Versioning
  network_version_id int [not null]                   // FK → version.id (must match node's version)
  
  // Standard metadata
  created_at  timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at  timestamp
  updated_by  int

  Indexes {
    (node_id, attr_key) [unique]                       // One value per key per node
    (attr_key)                                         // Find all nodes with specific attribute
    (network_version_id)                               // Version-specific queries
    (node_id)                                          // All attributes for a node
  }

  Note: 'Extension table for variable node attributes discovered in XML or added through domain knowledge'
}

// Foreign key relationships for Ring 1
Ref: network.arc.from_node_id > network.node.id [delete: restrict, update: cascade]
Ref: network.arc.to_node_id   > network.node.id [delete: restrict, update: cascade]
Ref: network.arc.arc_type_id  > network_arc_type.id [delete: restrict, update: cascade]
Ref: network.node.network_version_id > version.id [delete: restrict, update: cascade]
Ref: network.arc.network_version_id  > version.id [delete: restrict, update: cascade]
Ref: network.node_attributes.node_id > network.node.id [delete: cascade, update: cascade]
Ref: network.node_attributes.network_version_id > version.id [delete: restrict, update: cascade]
Ref: network.node.created_by > user.id [delete: restrict, update: cascade]
Ref: network.node.updated_by > user.id [delete: restrict, update: cascade]
Ref: network.arc.created_by  > user.id [delete: restrict, update: cascade]
Ref: network.arc.updated_by  > user.id [delete: restrict, update: cascade]
Ref: network.node_attributes.created_by > user.id [delete: restrict, update: cascade]
Ref: network.node_attributes.updated_by > user.id [delete: restrict, update: cascade]

//═══════════════════════════════════════════════
// RING 2: ENTITY VIEWS (Domain-Specific Rich Data)
// Multiple Sources: CalSim reports, domain expertise, GIS data
//═══════════════════════════════════════════════

Table reservoir_entity {
  id                   int    [pk, increment]
  network_node_id      int    [not null, unique]      // FK → network.node.id (Ring 1 reference)
  
  // Domain-derived identifiers (for convenience and legacy compatibility)
  short_code           text   [not null, unique]      // 'SHSTA', 'OROVL', 'FOLSM' (derived from network.node)
  name                 text   [not null]              // 'Shasta Reservoir', 'Lake Oroville'
  description          text                           // Detailed description from domain sources
  associated_river     text                           // 'Sacramento River', 'Feather River'
  
  // Legacy CalSim classifications (may be deprecated in favor of Ring 1)
  entity_type_id       int    [not null]              // FK → calsim_entity_type.id (currently "reservoir")
  schematic_type_id    int    [not null]              // FK → calsim_schematic_type.id (currently "node")

  
  // Regional classification
  hydrologic_region_id int                            // FK → hydrologic_region.id (SAC, SJR)
  
  // Rich physical characteristics (domain expertise)
  capacity_taf         numeric                        // Total capacity in TAF
  dead_pool_taf        numeric                        // Dead pool storage in TAF
  surface_area_acres   numeric                        // Surface area in acres
  operational_purpose  text                           // 'water_supply', 'flood_control', 'power_generation', 'water_quality', 'regulating', 'afterbay'
  
  // Domain-specific flags and attributes
  has_gis_data         boolean [default: false]       // Whether entity has spatial/geographic data
  has_tiers            boolean [not null, default: false]  // TRUE for reservoirs with tier classifications
  is_main              boolean [not null, default: false]  // TRUE for main/primary reservoirs in system
  
  // Versioning and source tracking (domain data, not network)
  entity_version_id    int    [not null]              // FK → version.id (domain entity data version)
  source_ids           int[]  [not null]              // Array of domain source IDs (reports, GIS, etc.)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (network_node_id) [unique]                         // One-to-one with network node
    (short_code) [unique]                              // Domain lookup
    (entity_version_id, short_code) [unique]           // Ensure unique short_code within each version
    (hydrologic_region_id)                             // Regional queries
    (hydrologic_region_id, entity_type_id) [note: 'Composite index for common queries']
    (has_gis_data)                                     // Find reservoirs with/without GIS data
    (has_tiers)                                        // Find tier reservoirs
    (is_main)                                          // Find main reservoirs
    (associated_river)                                 // Find reservoirs by river
    (operational_purpose)                              // Find reservoirs by operational purpose
    (entity_version_id)                                // Find entities by version
    (source_ids) [type: gin]                           // GIN index for array operations on source IDs
  }

  Note: '''
    Rich domain-specific data for reservoir entities. References Ring 1 network topology.
    CHECK (capacity_taf >= 0)
    CHECK (dead_pool_taf >= 0 AND dead_pool_taf <= capacity_taf)
  '''
}

// Foreign key relationships for Ring 2 - Reservoir Entity
Ref: reservoir_entity.network_node_id      > network.node.id [delete: restrict, update: cascade]
Ref: reservoir_entity.entity_type_id       > calsim_entity_type.id [delete: restrict, update: cascade]
Ref: reservoir_entity.schematic_type_id    > calsim_schematic_type.id [delete: restrict, update: cascade]
Ref: reservoir_entity.hydrologic_region_id > hydrologic_region.id  [delete: restrict, update: cascade]
Ref: reservoir_entity.entity_version_id    > version.id        [delete: restrict, update: cascade]
Ref: reservoir_entity.created_by           > user.id          [delete: restrict, update: cascade]
Ref: reservoir_entity.updated_by           > user.id          [delete: restrict, update: cascade]

Table inflow_entity {
  id                   int    [pk, increment]
  network_arc_id       int    [not null, unique]      // FK → network.arc.id (Ring 1 reference)
  
  // Domain-derived identifiers (for convenience and legacy compatibility)
  short_code           text   [not null, unique]      // 'I_SHSTA', 'I_OROVL', 'I_FOLSM' (derived from network.arc)
  name                 text   [not null]              // 'Shasta Lake Inflow', 'Lake Oroville Inflow'
  description          text                           // Detailed description from CalSim manual
  
  // Domain-specific inflow attributes
  to_node              text   [not null]              // Downstream node ID where inflow enters (legacy field)
  has_gis_data         boolean [default: false]       // Whether entity has spatial/geographic data
  
  // Legacy CalSim classifications (may be deprecated in favor of Ring 1)
  entity_type_id       int    [not null]              // FK → calsim_entity_type.id (currently "inflow")
  schematic_type_id    int    [not null]              // FK → calsim_schematic_type.id (currently "arc")
  
  // Regional classification
  hydrologic_region_id int                            // FK → hydrologic_region.id (SAC, SJR)
  
  // Versioning and source tracking (domain data, not network)
  entity_version_id    int    [not null]              // FK → version.id (domain entity data version)
  source_ids           int[]  [not null]              // Array of domain source IDs (reports, CalSim data, etc.)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (network_arc_id) [unique]                          // One-to-one with network arc
    (short_code) [unique]                              // Primary domain lookup
    (entity_version_id, short_code) [unique]           // Ensure unique short_code within each version
    (to_node)                                          // Find inflows by destination node
    (entity_type_id)                                   // Find inflows by entity type
    (schematic_type_id)                                // Find inflows by schematic type
    (hydrologic_region_id)                             // Find inflows by region
    (has_gis_data)                                     // Find inflows with/without GIS data
    (entity_version_id)                                // Find entities by version
    (source_ids) [type: gin]                           // GIN index for array operations on source IDs
  }

  Note: 'Rich domain-specific data for inflow entities. References Ring 1 network topology.'
}

// Foreign key relationships for Ring 2 - Inflow Entity
Ref: inflow_entity.network_arc_id       > network.arc.id [delete: restrict, update: cascade]
Ref: inflow_entity.entity_type_id       > calsim_entity_type.id [delete: restrict, update: cascade]
Ref: inflow_entity.schematic_type_id    > calsim_schematic_type.id [delete: restrict, update: cascade]
Ref: inflow_entity.hydrologic_region_id > hydrologic_region.id [delete: restrict, update: cascade]
Ref: inflow_entity.entity_version_id    > version.id        [delete: restrict, update: cascade]
Ref: inflow_entity.created_by           > user.id          [delete: restrict, update: cascade]
Ref: inflow_entity.updated_by           > user.id          [delete: restrict, update: cascade]

Table channel_entity {
  id                   int    [pk, increment]
  network_arc_id       int    [not null, unique]      // FK → network.arc.id (Ring 1 reference)
  
  // Domain-derived identifiers (for convenience and legacy compatibility)
  short_code           text   [not null, unique]      // 'C_SAC123', 'C_SJR456', 'C_AMR015' (derived from network.arc)
  name                 text   [not null]              // 'Sacramento River Section 123', 'American River'
  description          text                           // Detailed description from domain sources
  
  // Domain-specific channel attributes
  subtype              text                           // 'Stream', 'Canal', 'Bypass', 'Aqueduct'
  boundary_condition   text                           // From Central Valley Modeling doc
  from_node            text                           // Upstream node ID (legacy field)
  to_node              text                           // Downstream node ID (legacy field)
  
  // Physical characteristics
  length_m             numeric                        // Length in meters from GIS
  
  // Domain-specific flags and attributes
  has_tiers            boolean [not null, default: false]  // TRUE for channels with tier classifications
  is_main              boolean [not null, default: false]  // TRUE for main/primary channels in system
  has_gis_data         boolean [default: false]       // Whether variable has GIS data
  naming_convention    text                           // Naming convention pattern
  naming_prefix        text                           // Prefix extracted from calsim_id (e.g. "SAC", "AMR")
  
  // Legacy CalSim classifications (may be deprecated in favor of Ring 1)
  entity_type_id       int    [not null]              // FK → calsim_entity_type.id (currently "channel")
  schematic_type_id    int    [not null]              // FK → calsim_schematic_type.id (currently "arc")
  
  // Regional classification
  hydrologic_region_id int                            // FK → hydrologic_region.id
  
  // Versioning and source tracking (domain data, not network)
  entity_version_id    int    [not null]              // FK → version.id (domain entity data version)
  source_ids           int[]  [not null]              // Array of domain source IDs (reports, GIS, etc.)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (network_arc_id) [unique]                          // One-to-one with network arc
    (short_code) [unique]                              // Primary domain lookup
    (entity_version_id, short_code) [unique]           // Ensure unique short_code within each version
    (entity_type_id)                                   // Find channels by entity type
    (schematic_type_id)                                // Find channels by schematic type
    (hydrologic_region_id)                             // Regional queries
    (naming_prefix)                                    // Find channels by naming pattern
    (has_gis_data)                                     // Find channels with/without GIS data
    (subtype)                                          // Find channels by subtype
    (from_node)                                        // Legacy topology queries
    (to_node)                                          // Legacy topology queries
    (entity_version_id)                                // Find entities by version
    (source_ids) [type: gin]                           // GIN index for array operations on source IDs
  }

  Note: 'Rich domain-specific data for channel entities. References Ring 1 network topology.'
}

// Foreign key relationships for Ring 2 - Channel Entity
Ref: channel_entity.network_arc_id       > network.arc.id [delete: restrict, update: cascade]
Ref: channel_entity.entity_type_id       > calsim_entity_type.id [delete: restrict, update: cascade]
Ref: channel_entity.schematic_type_id    > calsim_schematic_type.id [delete: restrict, update: cascade]
Ref: channel_entity.hydrologic_region_id > hydrologic_region.id [delete: restrict, update: cascade]
Ref: channel_entity.entity_version_id    > version.id        [delete: restrict, update: cascade]
Ref: channel_entity.created_by           > user.id          [delete: restrict, update: cascade]
Ref: channel_entity.updated_by           > user.id          [delete: restrict, update: cascade]

//═══════════════════════════════════════════════
// RING 2: VARIABLE TABLES (Domain-Specific Variable Data)
// Multiple Sources: CalSim variables, reports, operational documents
//═══════════════════════════════════════════════

Table reservoir_variable {
  id                   int    [pk, increment]
  calsim_id            text   [not null, unique]      // 'S_SHSTA', 'S_SHSTA_1', 'S_SHSTA_2'
  name                 text   [not null]              // 'Shasta Total Storage', 'Shasta Flood Control Zone'
  description          text                           // Detailed description
  
  // Link to reservoir entity
  reservoir_entity_id  int    [not null]              // FK → reservoir_entity.id
  primary_entity_short_code text                      // Short code of primary entity this variable represents
  
  // Variable classification
  variable_type        text   [not null]              // 'storage_level', 'storage_zone', 'decision', 'state'
  storage_zone_type    text                           // 'total', 'flood_control', 'conservation', 'dead_pool', 'delta_reserve', 'carryover'
  operational_purpose  text                           // 'water_supply', 'flood_control', 'power_generation', 'water_quality'
  
  // Aggregation attributes
  is_aggregate         boolean [default: false]       // TRUE for variables that aggregate multiple reservoirs
  aggregated_variable_ids  uuid[]                     // Array of variable IDs that this variable aggregates
  
  // Operational thresholds
  trigger_threshold    numeric                        // Threshold value for operational triggers (e.g., 500 TAF)
  
  // Linkage and metadata
  unit_id              int                            // FK → unit.id
  temporal_scale_id    int                            // FK → temporal_scale.id (monthly, daily, etc.)
  variable_id           uuid
  variable_version_id  int    [not null]              // FK → version.id
  
  // Source tracking
  source_ids           int[]  [not null]              // Array of source IDs (FK → source.id)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by  int      [not null]
  updated_at           timestamp
  updated_by  int

  Indexes {
    (calsim_id) [unique]
    (reservoir_entity_id)                             // Find all variables for a reservoir
    (variable_type)                                   // Find variables by type (storage_level, storage_zone, etc.)
    (storage_zone_type)                               // Find variables by storage zone
    (operational_purpose)                             // Find variables by operational purpose
    (is_aggregate)                                    // Find aggregate variables
    (aggregated_variable_ids) [type: gin]            // GIN index for array operations on aggregated variables
    (source_ids) [type: gin]                          // GIN index for array operations on source IDs
  }

  Note: 'Storage and operational variables associated with reservoir entities'
}

Ref: reservoir_variable.reservoir_entity_id > reservoir_entity.id     [delete: cascade, update: cascade]
Ref: reservoir_variable.unit_id             > unit.id                 [delete: restrict, update: cascade]
Ref: reservoir_variable.variable_version_id > version.id                 [delete: restrict, update: cascade]
Ref: reservoir_variable.created_by          > user.id          [delete: restrict, update: cascade]
Ref: reservoir_variable.updated_by          > user.id          [delete: restrict, update: cascade]
Ref: reservoir_variable.temporal_scale_id      > temporal_scale.id    [delete: restrict, update: cascade]


Table inflow_variable {
  id                   int    [pk, increment]
  calsim_id            text   [not null, unique]      // 'I_SHSTA', 'I_OROVL', 'I_FOLSM'
  name                 text   [not null]              // 'Shasta Lake inflow rate'
  description          text                           // Detailed description from CalSim manual
  
  // Link to Ring 2 inflow entity
  inflow_entity_id     int    [not null]              // FK → inflow_entity.id
  
  // Variable classification (domain expertise)
  variable_type        text   [not null]              // 'inflow_rate', 'historical_inflow', 'projected_inflow'
  
  // Technical attributes
  unit_id              int                            // FK → unit.id (typically CFS)
  temporal_scale_id    int                            // FK → temporal_scale.id (monthly, daily, etc.)
  variable_id          uuid                           // Universal variable identifier
  variable_version_id  int    [not null]              // FK → version.id
  
  // Aggregation attributes
  is_aggregate         boolean [default: false]       // TRUE for variables that aggregate multiple inflows
  aggregated_variable_ids  uuid[]                     // Array of inflow variable IDs that this variable aggregates
  
  // Source tracking (domain variable data)
  source_ids           int[]  [not null]              // Array of source IDs (CalSim variables, reports, etc.)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (calsim_id) [unique]                              // Primary CalSim3 lookup
    (inflow_entity_id)                                // Find variables for an inflow entity
    (variable_type)                                   // Find variables by type
    (variable_id) [unique]                            // Link to main variable system (one-to-one)
    (is_aggregate)                                    // Find aggregate variables
    (aggregated_variable_ids) [type: gin]             // GIN index for array operations on aggregated variables
    (source_ids) [type: gin]                          // GIN index for array operations on source IDs
  }

  Note: 'Inflow rate variables (I_*) that measure water inputs to the system'
}

// Foreign key relationships for Ring 2 - Inflow Variable
Ref: inflow_variable.inflow_entity_id       > inflow_entity.id     [delete: cascade, update: cascade]
Ref: inflow_variable.unit_id                > unit.id              [delete: restrict, update: cascade]
Ref: inflow_variable.temporal_scale_id      > temporal_scale.id    [delete: restrict, update: cascade]
Ref: inflow_variable.variable_version_id    > version.id              [delete: restrict, update: cascade]
Ref: inflow_variable.created_by             > user.id          [delete: restrict, update: cascade]
Ref: inflow_variable.updated_by             > user.id          [delete: restrict, update: cascade]

Table channel_variable {
  id                   int    [pk, increment]
  calsim_id            text   [not null, unique]      // 'C_SAC123', 'UI_SAC123', 'MF_SAC123'
  name                 text   [not null]              // 'Sacramento River flow', 'Sacramento River unimpaired flow'
  description          text                           
  
  // Link to Ring 2 channel entity
  channel_entity_id    int    [not null]              // FK → channel_entity.id
  
  // Variable classification - CRITICAL FOR DOMAIN ANALYSIS
  variable_type        text   [not null]              // 'flow', 'unimpaired_flow', 'minimum_flow'
  
  // Technical attributes
  unit_id              int                            // FK → unit.id (typically CFS)
  temporal_scale_id    int                            // FK → temporal_scale.id (monthly, daily, etc.)
  variable_id          uuid                           // Universal variable identifier
  variable_version_id  int    [not null]              // FK → version.id
  
  // Regulatory/operational (domain expertise)
  is_regulatory        boolean [default: false]       // TRUE for minimum instream flow requirements
  regulatory_authority text                           // Agency setting the requirement

  // Aggregation attributes
  is_aggregate         boolean [default: false]       // TRUE for variables that aggregate multiple channels
  aggregated_variable_ids  uuid[]                     // Array of channel variable IDs that this variable aggregates 
  
  // Linkage to outcomes
  outcome_category_short_code text                    // FK reference to outcome_category
  
  // Source tracking (domain variable data)
  source_ids           int[]  [not null]              // Array of source IDs (CalSim variables, reports, etc.)
  
  // Standard metadata
  created_at           timestamp [default: "now()"]
  created_by           int    [not null]
  updated_at           timestamp
  updated_by           int

  Indexes {
    (calsim_id) [unique]                              // Primary CalSim3 lookup
    (channel_entity_id)                               // Find variables for a channel entity
    (variable_type)                                   // Find by type: flow, unimpaired_flow, minimum_flow
    (is_regulatory)                                   // Find regulatory requirements
    (is_aggregate)                                    // Find aggregate variables
    (aggregated_variable_ids) [type: gin]             // GIN index for array operations on aggregated variables
    (variable_id)                                     // Link to main variable system
    (source_ids) [type: gin]                          // GIN index for array operations on source IDs
  }

  Note: 'Flow variables for channels including scenario flow, unimpaired flow, and minimum instream flow'
}

// Foreign key relationships for Ring 2 - Channel Variable
Ref: channel_variable.channel_entity_id     > channel_entity.id    [delete: cascade, update: cascade]
Ref: channel_variable.unit_id               > unit.id              [delete: restrict, update: cascade]
Ref: channel_variable.temporal_scale_id     > temporal_scale.id    [delete: restrict, update: cascade]
Ref: channel_variable.variable_version_id   > version.id              [delete: restrict, update: cascade]
Ref: channel_variable.created_by            > user.id          [delete: restrict, update: cascade]
Ref: channel_variable.updated_by            > user.id          [delete: restrict, update: cascade]

//═══════════════════════════════════════════════
// RING 3: SUMMARY STATISTICS & OUTCOMES (documentation, these tables exist above from previous version TODO: rewrite schema to integrate.)
// Ring 3 and Ring 4 tables reference variables from Ring 2, which now properly link to Ring 1 topology.
//═══════════════════════════════════════════════

/*
Ring 3 tables:
- scenario_variable_statistic (links to Ring 2 variables)
- scenario_measure_statistic (links to outcome measures)
- scenario_outcome_statistic (aggregated outcomes)

Ring 4 tables:  
- theme (interpretive framework)
- tier_definition (analysis framework)
- outcome_measure (links to Ring 2 variables via measure_variable_link)
*/

//═══════════════════════════════════════════════
// RING ARCHITECTURE INTEGRATION WITH EXISTING OUTCOME SYSTEM
//═══════════════════════════════════════════════

/*
RING-BASED CALSIM ARCHITECTURE DOCUMENTATION/SUMMARY/THINKING:

RING 1: GRAPH CORE (Network Topology)
   - network.node: Core network nodes (reservoirs, junctions, diversions)
   - network.arc: Core network arcs (inflows, channels, bypasses)
   - network.node_attributes: Extension table for variable node attributes
   - network_arc_type: Lookup table for arc types (consistency)
   - Source: CS3_NetworkSchematic_Integrated_11.28.23.xml
   - Purpose: Authoritative network topology and connectivity

RING 2: ENTITY VIEWS (Domain-Specific Rich Data)
   - reservoir_entity: Rich domain data for reservoirs (capacity, operational purpose, etc.)
   - inflow_entity: Rich domain data for inflows (descriptions, regional classification)
   - channel_entity: Rich domain data for channels (length, subtype, naming patterns)
   - reservoir_variable, inflow_variable, channel_variable: Rich variable classifications
   - Sources: CalSim reports, domain expertise, GIS data, operational documents
   - Purpose: Preserve domain expertise while linking to network topology

RING 3: SUMMARY STATISTICS (Existing - No Changes)
   - scenario_variable_statistic: Variable values per scenario
   - scenario_measure_statistic: Outcome measure values per scenario
   - Purpose: Store computational results and analysis outcomes

RING 4: INTERPRETIVE FRAMEWORK (Existing - No Changes)  
   - theme, tier_definition, outcome_measure: Analysis and interpretation framework
   - Purpose: Support dashboard views and research analysis

KEY ARCHITECTURAL BENEFITS:
- Single source of truth for network topology (Ring 1)
- Rich domain expertise preserved (Ring 2)
- Network analysis capabilities enabled
- Independent versioning for topology vs domain data
- Seamless integration with existing outcome system
- Supports both entity-focused and network-focused queries

OUTCOME FLOW:

1. ENTITY TABLES → VARIABLE TABLES → OUTCOME STATISTICS

   Physical Entities                Variable Tables                  Outcome Statistics
   ─────────────────              ──────────────────               ─────────────────────
   
   reservoir_entity     ────→      reservoir_variable      ────→    scenario_variable_statistic
   │                               │                               │
   ├─ SHSTA                        ├─ S_SHSTA                      └─ Storage statistics per scenario
   ├─ OROVL                        ├─ S_SHSTA_1                    
   └─ FOLSM                        └─ S_OROVL                      
   
   inflow_entity        ────→      inflow_variable         ────→    scenario_variable_statistic
   │                               │                               │
   ├─ I_SHSTA                      ├─ I_SHSTA                      └─ Inflow statistics per scenario
   ├─ I_OROVL                      ├─ I_OROVL                      
   └─ I_FOLSM                      └─ I_FOLSM                      
   
   channel_entity       ────→      channel_variable        ────→    scenario_variable_statistic
   │                               │                               │
   ├─ SAC123                       ├─ C_SAC123 (scenario_flow)     └─ Flow statistics per scenario
   │                               ├─ C_SAC123_UNIMPAIRED (unimpaired_flow) 
   │                               └─ C_SAC123_MIF (minimum_instream_flow)  
   └─ SJR456                       
   
2. KEY LINKING FIELDS:

   All variable tables have:
   - variable_id (uuid) → each variable has its own UUID as primary key
   - outcome_category_short_code → links to outcome_category.short_code
   
   This enables queries like:
   ```sql
   -- Find all scenario statistics for Shasta storage variables
   SELECT sv.scenario_id, rv.name, sv.statistic_type_id, sv.value
   FROM reservoir_variable rv
   JOIN scenario_variable_statistic sv ON rv.variable_id = sv.variable_id
   WHERE rv.reservoir_entity_id = (
     SELECT id FROM reservoir_entity WHERE short_code = 'SHSTA'
   );
   
   -- Compare scenario flow vs unimpaired flow for Sacramento River
   SELECT 
     chv.calsim_id,
     chv.variable_type,
     sv.statistic_type_id,
     sv.value
   FROM channel_variable chv
   JOIN scenario_variable_statistic sv ON chv.variable_id = sv.variable_id
   WHERE chv.channel_entity_id = (
     SELECT id FROM channel_entity WHERE short_code = 'SAC123'
   )
   AND chv.variable_type IN ('flow', 'unimpaired_flow')
   ORDER BY chv.variable_type, sv.statistic_type_id;
   ```

3. OUTCOME MEASURES:

   Variables can link to outcome_measure for aggregated metrics:
   - measure_variable_link connects entity-specific variable tables → outcome_measure
   - scenario_measure_statistic stores calculated outcome statistics
   
   This enables outcome-based analysis across multiple variables.
*/

//═══════════════════════════════════════════════
// NETWORK-FOCUSED THEME INTEGRATION
// Purpose: Enable themes to highlight specific network regions or critical infrastructure
//═══════════════════════════════════════════════

Table theme_network_region_link {
  theme_id            int [not null]           // FK → theme.id
  hydrologic_region_id int [not null]          // FK → hydrologic_region.id
  focus_description   text                     // "Primary network focus area for this theme"
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]

  Indexes {
    (theme_id, hydrologic_region_id) [pk]
    (hydrologic_region_id, theme_id)
  }

  Note: 'Links themes to specific network regions for research focus (e.g., "Sacramento Valley Connectivity")'
}

Ref: theme_network_region_link.theme_id            > theme.id             [delete: cascade, update: cascade]
Ref: theme_network_region_link.hydrologic_region_id > hydrologic_region.id [delete: restrict, update: cascade]
Ref: theme_network_region_link.created_by          > user.id      [delete: restrict, update: cascade]

Table theme_entity_type_focus {
  theme_id           int  [not null]           // FK → theme.id
  entity_type_id     int  [not null]           // FK → calsim_entity_type.id
  focus_description  text                      // "Primary focus on reservoir storage entities"
  focus_weight       numeric [default: 1.0]    // Relative importance weight (0.0-1.0)
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]

  Indexes {
    (theme_id, entity_type_id) [pk]
    (entity_type_id, theme_id)
  }

  Note: 'Links themes to broad entity type focus areas (e.g., all reservoir entities, all groundwater entities)'
}

Ref: theme_entity_type_focus.theme_id       > theme.id              [delete: cascade, update: cascade]
Ref: theme_entity_type_focus.entity_type_id > calsim_entity_type.id [delete: restrict, update: cascade]
Ref: theme_entity_type_focus.created_by     > user.id               [delete: restrict, update: cascade]

Table theme_focus_entity_link {
  theme_id     int  [not null]           // FK → theme.id
  node_id      int                       // FK → network.node.id (nullable)
  arc_id       int                       // FK → network.arc.id (nullable)
  significance text [not null]           // 'critical_bottleneck', 'key_junction', 'major_input', 'outcome_point'
  description  text                      // Research rationale for highlighting this specific network element
  
  created_at  timestamp [not null, default: "now()"]
  created_by  int      [not null]

  Indexes {
    (theme_id, node_id, arc_id) [pk]
    (node_id)
    (arc_id)
    (significance)
  }

  Note: 'Links themes to specific network nodes or arcs for focused analysis. CHECK ((node_id IS NOT NULL)::int + (arc_id IS NOT NULL)::int = 1) -- Exactly one of node_id or arc_id must be specified'
}

Ref: theme_focus_entity_link.theme_id > theme.id         [delete: cascade, update: cascade]
Ref: theme_focus_entity_link.node_id  > network.node.id  [delete: restrict, update: cascade]
Ref: theme_focus_entity_link.arc_id   > network.arc.id   [delete: restrict, update: cascade]
Ref: theme_focus_entity_link.created_by > user.id        [delete: restrict, update: cascade]

//────────────────────────────────────────────
// MATERIALIZED VIEWS (with read-only optimization)
//────────────────────────────────────────────

// Note: These are materialized views, not regular tables
// They will be created by the materialized_views.sql script
/*

View scenario_dashboard_summary {
  id                      int
  short_code              text
  title                   text
  subtitle                text
  description             text
  is_active               boolean
  author_name             text
  author_organization     text
  hydroclimate_code       text
  hydroclimate_name       text
  projection_year         int
  baseline_scenario_code  text
  baseline_scenario_title text
  theme_count             bigint
  variable_count          bigint
  measure_count           bigint
  avg_variable_value      numeric
  min_variable_value      numeric
  max_variable_value      numeric
  created_at              timestamp
  updated_at              timestamp
  
  Note: 'Materialized view for scenario dashboard performance'
}

View theme_analysis_summary {
  id                      int
  short_code              text
  title                   text
  subtitle                text
  description             text
  is_active               boolean
  primary_source_code     text
  primary_source_name     text
  primary_source_citation text
  scenario_count          bigint
  active_scenario_count   bigint
  outcome_category_count  bigint
  avg_focus_weight        numeric
  assumption_count        bigint
  operation_count         bigint
  created_at              timestamp
  updated_at              timestamp
  
  Note: 'Materialized view for theme analysis performance'
}

View variable_statistics_summary {
  variable_id             uuid
  statistic_code          text
  statistic_name          text
  scenario_count          bigint
  active_scenario_count   bigint
  avg_value               numeric
  min_value               numeric
  max_value               numeric
  stddev_value            numeric
  p25_value               numeric
  median_value            numeric
  p75_value               numeric
  p90_value               numeric
  last_updated            timestamp
  
  Note: 'Materialized view for pre-aggregated variable statistics'
}

View entity_inventory_summary {
  entity_type             text
  entity_id               int
  entity_code             text
  entity_name             text
  capacity_taf            numeric
  dead_pool_taf           numeric
  operational_purpose     text
  hydrologic_region_code  text
  hydrologic_region_name  text
  variable_count          bigint
  scenario_count          bigint
  source_list             text[]
  created_at              timestamp
  updated_at              timestamp
  
  Note: 'Materialized view for comprehensive entity inventory'
}

View outcome_measurement_summary {
  measure_id              int
  measure_code            text
  measure_name            text
  category_code           text
  category_label          text
  unit_code               text
  unit_name               text
  temporal_scale_code     text
  spatial_scale_code      text
  theme_count             bigint
  theme_codes             text[]
  scenario_count          bigint
  avg_value               numeric
  min_value               numeric
  max_value               numeric
  created_at              timestamp
  updated_at              timestamp
  
  Note: 'Materialized view for outcome measurement analysis'
}
*/